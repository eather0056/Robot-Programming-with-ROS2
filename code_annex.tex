
\appendix

\chapter[Source Code]{Source Code}
\label{cap:source}
Complete list of source code used in the book, also available in:

\vspace{0.5cm}
\large
\texttt{https://github.com/fmrico/book\_ros2}
\normalsize
)
\section{Package \texttt{br2\_basics}}
\label{sec:anex:br2_basics}

 \footnotesize
\begin{tcolorbox}[sharp corners, colframe=gray!80, colback=LightGray, left=0pt, top=0pt, bottom=0pt, title=Package \texttt{br2\_basics}]
  \begin{minted}[
    framesep=2mm,
    baselinestretch=0.8,
    bgcolor=LightGreen,
    fontsize=\scriptsize
  ]{console}
br2_basics
├── CMakeLists.txt
├── config
│   └── params.yaml
├── launch
│   ├── includer_launch.py
│   ├── param_node_v1_launch.py
│   ├── param_node_v2_launch.py
│   ├── pub_sub_v1_launch.py
│   └── pub_sub_v2_launch.py
├── package.xml
└── src
    ├── executors.cpp
    ├── logger_class.cpp
    ├── logger.cpp
    ├── param_reader.cpp
    ├── publisher_class.cpp
    ├── publisher.cpp
    └── subscriber_class.cpp    \end{minted}
    \end{tcolorbox}
  \normalsize

 \footnotesize
\begin{tcolorbox}[sharp corners, colframe=gray!80, colback=LightGray, left=0pt, top=0pt, bottom=0pt, title=\texttt{br2\_basics/CMakeLists.txt}]
  \begin{minted}[
    framesep=2mm,
    baselinestretch=0.8,
    bgcolor=LightGray,
    fontsize=\scriptsize
  ]{CMake}
cmake_minimum_required(VERSION 3.5)
project(br2_basics)

find_package(ament_cmake REQUIRED)
find_package(rclcpp REQUIRED)
find_package(std_msgs REQUIRED)

set(dependencies
    rclcpp
    std_msgs
)

add_executable(publisher src/publisher.cpp)
ament_target_dependencies(publisher ${dependencies})

add_executable(publisher_class src/publisher_class.cpp)
ament_target_dependencies(publisher_class ${dependencies})

add_executable(subscriber_class src/subscriber_class.cpp)
ament_target_dependencies(subscriber_class ${dependencies})

add_executable(executors src/executors.cpp)
ament_target_dependencies(executors ${dependencies})

add_executable(logger src/logger.cpp)
ament_target_dependencies(logger ${dependencies})

add_executable(logger_class src/logger_class.cpp)
ament_target_dependencies(logger_class ${dependencies})

add_executable(param_reader src/param_reader.cpp)
ament_target_dependencies(param_reader ${dependencies})

install(TARGETS
  publisher
  publisher_class
  subscriber_class
  executors
  logger
  logger_class
  param_reader
  ARCHIVE DESTINATION lib
  LIBRARY DESTINATION lib
  RUNTIME DESTINATION lib/${PROJECT_NAME}
)

install(DIRECTORY launch config DESTINATION share/${PROJECT_NAME})

if(BUILD_TESTING)
  find_package(ament_lint_auto REQUIRED)
  ament_lint_auto_find_test_dependencies()
endif()

ament_export_dependencies(${dependencies})
ament_package()
    \end{minted}
    \end{tcolorbox}
  \normalsize

 \footnotesize
\begin{tcolorbox}[sharp corners, colframe=gray!80, colback=LightGray, left=0pt, top=0pt, bottom=0pt, title=\texttt{br2\_basics/launch/param\_node\_v2\_launch.py}]
  \begin{minted}[
    framesep=2mm,
    baselinestretch=0.8,
    bgcolor=LightGray,
    fontsize=\scriptsize
  ]{Python}
import os

from ament_index_python.packages import get_package_share_directory

from launch import LaunchDescription
from launch_ros.actions import Node

def generate_launch_description():

  pkg_dir = get_package_share_directory('basics')
  param_file = os.path.join(pkg_dir, 'config', 'params.yaml')

  param_reader_cmd = Node(
    package='basics',
    executable='param_reader',
    parameters=[param_file],
    output='screen'
  )

  ld = LaunchDescription()
  ld.add_action(param_reader_cmd)

  return ld
    \end{minted}
    \end{tcolorbox}
  \normalsize

 \footnotesize
\begin{tcolorbox}[sharp corners, colframe=gray!80, colback=LightGray, left=0pt, top=0pt, bottom=0pt, title=\texttt{br2\_basics/launch/pub\_sub\_v2\_launch.py}]
  \begin{minted}[
    framesep=2mm,
    baselinestretch=0.8,
    bgcolor=LightGray,
    fontsize=\scriptsize
  ]{Python}
from launch import LaunchDescription
from launch_ros.actions import Node

def generate_launch_description():

  return LaunchDescription([
    Node(
      package='basics',
      executable='publisher',
      output='screen'
    ),
    Node(
      package='basics',
      executable='subscriber_class',
      output='screen'
    )
  ])
    \end{minted}
    \end{tcolorbox}
  \normalsize

 \footnotesize
\begin{tcolorbox}[sharp corners, colframe=gray!80, colback=LightGray, left=0pt, top=0pt, bottom=0pt, title=\texttt{br2\_basics/launch/pub\_sub\_v1\_launch.py}]
  \begin{minted}[
    framesep=2mm,
    baselinestretch=0.8,
    bgcolor=LightGray,
    fontsize=\scriptsize
  ]{Python}
from launch import LaunchDescription
from launch_ros.actions import Node

def generate_launch_description():

  pub_cmd = Node(
    package='basics',
    executable='publisher',
    output='screen'
  )
  sub_cmd = Node(
    package='basics',
    executable='subscriber_class',
    output='screen'
  )

  ld = LaunchDescription()
  ld.add_action(pub_cmd)
  ld.add_action(sub_cmd)

  return ld
    \end{minted}
    \end{tcolorbox}
  \normalsize

 \footnotesize
\begin{tcolorbox}[sharp corners, colframe=gray!80, colback=LightGray, left=0pt, top=0pt, bottom=0pt, title=\texttt{br2\_basics/launch/includer\_launch.py}]
  \begin{minted}[
    framesep=2mm,
    baselinestretch=0.8,
    bgcolor=LightGray,
    fontsize=\scriptsize
  ]{Python}
import os

from ament_index_python.packages import get_package_share_directory
from launch import LaunchDescription
from launch.actions import IncludeLaunchDescription
from launch.launch_description_sources import PythonLaunchDescriptionSource

def generate_launch_description():

  return LaunchDescription([
    IncludeLaunchDescription(
      PythonLaunchDescriptionSource(os.path.join(
        get_package_share_directory('basics'),
          'launch',
          'pub_sub_v2_launch.py'))
    )
  ])
    \end{minted}
    \end{tcolorbox}
  \normalsize

 \footnotesize
\begin{tcolorbox}[sharp corners, colframe=gray!80, colback=LightGray, left=0pt, top=0pt, bottom=0pt, title=\texttt{br2\_basics/launch/param\_node\_v1\_launch.py}]
  \begin{minted}[
    framesep=2mm,
    baselinestretch=0.8,
    bgcolor=LightGray,
    fontsize=\scriptsize
  ]{Python}
from launch import LaunchDescription
from launch_ros.actions import Node

def generate_launch_description():

  param_reader_cmd = Node(
    package='basics',
    executable='param_reader',
    parameters=[{
      'particles': 300,
      'topics': ['scan', 'image'],
      'topic_types': ['sensor_msgs/msg/LaserScan', 'sensor_msgs/msg/Image']
    }],
    output='screen'
  )

  ld = LaunchDescription()
  ld.add_action(param_reader_cmd)

  return ld
    \end{minted}
    \end{tcolorbox}
  \normalsize

 \footnotesize
\begin{tcolorbox}[sharp corners, colframe=gray!80, colback=LightGray, left=0pt, top=0pt, bottom=0pt, title=\texttt{br2\_basics/package.xml}]
  \begin{minted}[
    framesep=2mm,
    baselinestretch=0.8,
    bgcolor=LightGray,
    fontsize=\scriptsize
  ]{XML}
<?xml version="1.0"?>
<?xml-model href="http://download.ros.org/schema/package_format3.xsd" schematypens="http://www.w3.org/2001/XMLSchema"?>
<package format="3">
  <name>br2_basics</name>
  <version>0.0.0</version>
  <description>Basic nodes for ROS2 introduction</description>
  <maintainer email="fmrico@gmail.com">fmrico</maintainer>
  <license>Apache 2</license>

  <buildtool_depend>ament_cmake</buildtool_depend>

  <depend>rclcpp</depend>
  <depend>std_msgs</depend>

  <test_depend>ament_lint_auto</test_depend>
  <test_depend>ament_lint_common</test_depend>

  <export>
    <build_type>ament_cmake</build_type>
  </export>
</package>    \end{minted}
    \end{tcolorbox}
  \normalsize

 \footnotesize
\begin{tcolorbox}[sharp corners, colframe=gray!80, colback=LightGray, left=0pt, top=0pt, bottom=0pt, title=\texttt{br2\_basics/config/params.yaml}]
  \begin{minted}[
    framesep=2mm,
    baselinestretch=0.8,
    bgcolor=LightGray,
    fontsize=\scriptsize
  ]{Yaml}
localization_node:
  ros__parameters:
    number_particles: 300
    topics: [scan, image]
    topic_types: [sensor_msgs/msg/LaserScan, sensor_msgs/msg/Image]
    \end{minted}
    \end{tcolorbox}
  \normalsize

 \footnotesize
\begin{tcolorbox}[sharp corners, colframe=gray!80, colback=LightGray, left=0pt, top=0pt, bottom=0pt, title=\texttt{br2\_basics/src/logger\_class.cpp}]
  \begin{minted}[
    framesep=2mm,
    baselinestretch=0.8,
    bgcolor=LightGray,
    fontsize=\scriptsize
  ]{CPP}
// Copyright 2021 Intelligent Robotics Lab
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

#include "rclcpp/rclcpp.hpp"

using namespace std::chrono_literals;

class LoggerNode : public rclcpp::Node
{
public:
  LoggerNode() : Node("logger_node")
  {
    counter_ = 0;
    timer_ = create_wall_timer(
      500ms, std::bind(&LoggerNode::timer_callback, this));
  }

  void timer_callback()
  {
    RCLCPP_INFO(get_logger(), "Hello %d", counter_++);
  }

private:
  rclcpp::TimerBase::SharedPtr timer_;
  int counter_;
};

int main(int argc, char * argv[]) {
  rclcpp::init(argc, argv);

  auto node = std::make_shared<LoggerNode>();

  rclcpp::spin(node);

  rclcpp::shutdown();
  return 0;
}    \end{minted}
    \end{tcolorbox}
  \normalsize

 \footnotesize
\begin{tcolorbox}[sharp corners, colframe=gray!80, colback=LightGray, left=0pt, top=0pt, bottom=0pt, title=\texttt{br2\_basics/src/subscriber\_class.cpp}]
  \begin{minted}[
    framesep=2mm,
    baselinestretch=0.8,
    bgcolor=LightGray,
    fontsize=\scriptsize
  ]{CPP}
// Copyright 2021 Intelligent Robotics Lab
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

#include "rclcpp/rclcpp.hpp"
#include "std_msgs/msg/int32.hpp"

using std::placeholders::_1;

class SubscriberNode : public rclcpp::Node
{
public:
  SubscriberNode() : Node("subscriber_node")
  {
    subscriber_ = create_subscription<std_msgs::msg::Int32>("int_topic", 10,
      std::bind(&SubscriberNode::callback, this, _1));
  }

  void callback(const std_msgs::msg::Int32::SharedPtr msg)
  {
    RCLCPP_INFO(get_logger(), "Hello %d", msg->data);
  }

private:
  rclcpp::Subscription<std_msgs::msg::Int32>::SharedPtr subscriber_;
};

int main(int argc, char * argv[]) {
  rclcpp::init(argc, argv);

  auto node = std::make_shared<SubscriberNode>();

  rclcpp::spin(node);

  rclcpp::shutdown();
  return 0;
}    \end{minted}
    \end{tcolorbox}
  \normalsize

 \footnotesize
\begin{tcolorbox}[sharp corners, colframe=gray!80, colback=LightGray, left=0pt, top=0pt, bottom=0pt, title=\texttt{br2\_basics/src/publisher.cpp}]
  \begin{minted}[
    framesep=2mm,
    baselinestretch=0.8,
    bgcolor=LightGray,
    fontsize=\scriptsize
  ]{CPP}
// Copyright 2021 Intelligent Robotics Lab
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

#include "rclcpp/rclcpp.hpp"
#include "std_msgs/msg/int32.hpp"

using namespace std::chrono_literals;

int main(int argc, char * argv[]) {
  rclcpp::init(argc, argv);

  auto node = rclcpp::Node::make_shared("publisher_node");
  auto publisher = node->create_publisher<std_msgs::msg::Int32>(
    "int_topic", 10);

  std_msgs::msg::Int32 message;
  message.data = 0;

  rclcpp::Rate loop_rate(500ms);
  while (rclcpp::ok()) {
    message.data += 1;
    publisher->publish(message);

    rclcpp::spin_some(node);
    loop_rate.sleep();
  }

  rclcpp::shutdown();
  return 0;
}     \end{minted}
    \end{tcolorbox}
  \normalsize

 \footnotesize
\begin{tcolorbox}[sharp corners, colframe=gray!80, colback=LightGray, left=0pt, top=0pt, bottom=0pt, title=\texttt{br2\_basics/src/param\_reader.cpp}]
  \begin{minted}[
    framesep=2mm,
    baselinestretch=0.8,
    bgcolor=LightGray,
    fontsize=\scriptsize
  ]{CPP}
// Copyright 2021 Intelligent Robotics Lab
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

#include <vector>
#include <string>

#include "rclcpp/rclcpp.hpp"

class LocalizationNode : public rclcpp::Node
{
public:
  LocalizationNode() : Node("localization_node")
  {
    declare_parameter<int>("number_particles", 200);
    declare_parameter<std::vector<std::string>>("topics", {});
    declare_parameter<std::vector<std::string>>("topic_types", {});

    get_parameter("number_particles", num_particles_);
    RCLCPP_INFO_STREAM(get_logger(), "Number of particles: " << num_particles_);

    get_parameter("topics", topics_);
    get_parameter("topic_types", topic_types_);

    if (topics_.size() != topic_types_.size()) {
      RCLCPP_ERROR(get_logger(), "Number of topics (%zu) != number of types (%zu)",
        topics_.size(), topic_types_.size());
    } else {
      RCLCPP_INFO_STREAM(get_logger(), "Number of topics: " << topics_.size());
      for (size_t i = 0; i < topics_.size(); i++) {
        RCLCPP_INFO_STREAM(get_logger(), "\t" << topics_[i] << "\t - " << topic_types_[i]);
      }
    }
  }

private:
  int num_particles_;
  std::vector<std::string> topics_;
  std::vector<std::string> topic_types_;
};

int main(int argc, char * argv[]) {
  rclcpp::init(argc, argv);

  auto node = std::make_shared<LocalizationNode>();

  rclcpp::spin(node);

  rclcpp::shutdown();
  return 0;
}
    \end{minted}
    \end{tcolorbox}
  \normalsize

 \footnotesize
\begin{tcolorbox}[sharp corners, colframe=gray!80, colback=LightGray, left=0pt, top=0pt, bottom=0pt, title=\texttt{br2\_basics/src/executors.cpp}]
  \begin{minted}[
    framesep=2mm,
    baselinestretch=0.8,
    bgcolor=LightGray,
    fontsize=\scriptsize
  ]{CPP}
// Copyright 2021 Intelligent Robotics Lab
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

#include "rclcpp/rclcpp.hpp"

#include "std_msgs/msg/int32.hpp"

using namespace std::chrono_literals;
using std::placeholders::_1;

class PublisherNode : public rclcpp::Node
{
public:
  PublisherNode() : Node("publisher_node")
  {
    publisher_ = create_publisher<std_msgs::msg::Int32>("int_topic", 10);
    timer_ = create_wall_timer(
      500ms, std::bind(&PublisherNode::timer_callback, this));
  }

  void timer_callback()
  {
    message_.data += 1;
    publisher_->publish(message_);
  }

private:
  rclcpp::Publisher<std_msgs::msg::Int32>::SharedPtr publisher_;
  rclcpp::TimerBase::SharedPtr timer_;
  std_msgs::msg::Int32 message_;
};

class SubscriberNode : public rclcpp::Node
{
public:
  SubscriberNode() : Node("subscriber_node")
  {
    subscriber_ = create_subscription<std_msgs::msg::Int32>("int_topic", 10,
      std::bind(&SubscriberNode::callback, this, _1));
  }

  void callback(const std_msgs::msg::Int32::SharedPtr msg)
  {
    RCLCPP_INFO(get_logger(), "Hello %d", msg->data);
  }

private:
  rclcpp::Subscription<std_msgs::msg::Int32>::SharedPtr subscriber_;
};

int main(int argc, char * argv[]) {
  rclcpp::init(argc, argv);

  auto node_pub = std::make_shared<PublisherNode>();
  auto node_sub = std::make_shared<SubscriberNode>();

  rclcpp::executors::SingleThreadedExecutor executor;
  // rclcpp::executors::MultiThreadedExecutor executor(
  //   rclcpp::executor::ExecutorArgs(), 8);

  executor.add_node(node_pub);
  executor.add_node(node_sub);

  executor.spin();

  rclcpp::shutdown();
  return 0;
}    \end{minted}
    \end{tcolorbox}
  \normalsize

 \footnotesize
\begin{tcolorbox}[sharp corners, colframe=gray!80, colback=LightGray, left=0pt, top=0pt, bottom=0pt, title=\texttt{br2\_basics/src/publisher\_class.cpp}]
  \begin{minted}[
    framesep=2mm,
    baselinestretch=0.8,
    bgcolor=LightGray,
    fontsize=\scriptsize
  ]{CPP}
// Copyright 2021 Intelligent Robotics Lab
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

#include "rclcpp/rclcpp.hpp"

#include "std_msgs/msg/int32.hpp"

using namespace std::chrono_literals;
using std::placeholders::_1;

class PublisherNode : public rclcpp::Node
{
public:
  PublisherNode() : Node("publisher_node")
  {
    publisher_ = create_publisher<std_msgs::msg::Int32>("int_topic", 10);
    timer_ = create_wall_timer(
      500ms, std::bind(&PublisherNode::timer_callback, this));
  }

  void timer_callback()
  {
    message_.data += 1;
    publisher_->publish(message_);
  }

private:
  rclcpp::Publisher<std_msgs::msg::Int32>::SharedPtr publisher_;
  rclcpp::TimerBase::SharedPtr timer_;
  std_msgs::msg::Int32 message_;
};

int main(int argc, char * argv[]) {
  rclcpp::init(argc, argv);

  auto node = std::make_shared<PublisherNode>();

  rclcpp::spin(node);

  rclcpp::shutdown();
  return 0;
}    \end{minted}
    \end{tcolorbox}
  \normalsize

 \footnotesize
\begin{tcolorbox}[sharp corners, colframe=gray!80, colback=LightGray, left=0pt, top=0pt, bottom=0pt, title=\texttt{br2\_basics/src/logger.cpp}]
  \begin{minted}[
    framesep=2mm,
    baselinestretch=0.8,
    bgcolor=LightGray,
    fontsize=\scriptsize
  ]{CPP}
// Copyright 2021 Intelligent Robotics Lab
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

#include "rclcpp/rclcpp.hpp"

using namespace std::chrono_literals;

int main(int argc, char * argv[]) {
  rclcpp::init(argc, argv);

  auto node = rclcpp::Node::make_shared("logger_node");

  rclcpp::Rate loop_rate(500ms);
  int counter = 0;
  while (rclcpp::ok()) {
    RCLCPP_INFO(node->get_logger(), "Hello %d", counter++);

    rclcpp::spin_some(node);
    loop_rate.sleep();
  }

  rclcpp::shutdown();
  return 0;
}     \end{minted}
    \end{tcolorbox}
  \normalsize



\appendix

\chapter[Source Code]{Source Code}
\label{cap:source}
Complete list of source code used in the book, also available in:

\vspace{0.5cm}
\large
\texttt{https://github.com/fmrico/book\_ros2}
\normalsize
)
\section{Package \texttt{br2\_fsm\_bumpgo\_cpp}}
\label{sec:anex:br2_fsm_bumpgo_cpp}

 \footnotesize
\begin{tcolorbox}[sharp corners, colframe=gray!80, colback=LightGray, left=0pt, top=0pt, bottom=0pt, title=Package \texttt{br2\_fsm\_bumpgo\_cpp}]
  \begin{minted}[
    framesep=2mm,
    baselinestretch=0.8,
    bgcolor=LightGreen,
    fontsize=\scriptsize
  ]{console}
br2_fsm_bumpgo_cpp
├── CMakeLists.txt
├── include
│   └── br2_fsm_bumpgo_cpp
│       └── BumpGoNode.hpp
├── launch
│   └── bump_and_go.launch.py
├── package.xml
└── src
    ├── br2_fsm_bumpgo_cpp
    │   └── BumpGoNode.cpp
    └── bumpgo_main.cpp    \end{minted}
    \end{tcolorbox}
  \normalsize

 \footnotesize
\begin{tcolorbox}[sharp corners, colframe=gray!80, colback=LightGray, left=0pt, top=0pt, bottom=0pt, title=\texttt{br2\_fsm\_bumpgo\_cpp/CMakeLists.txt}]
  \begin{minted}[
    framesep=2mm,
    baselinestretch=0.8,
    bgcolor=LightGray,
    fontsize=\scriptsize
  ]{CMake}
cmake_minimum_required(VERSION 3.5)
project(br2_fsm_bumpgo_cpp)

set(CMAKE_CXX_STANDARD 17)

find_package(ament_cmake REQUIRED)
find_package(rclcpp REQUIRED)
find_package(sensor_msgs REQUIRED)
find_package(geometry_msgs REQUIRED)

set(dependencies
  rclcpp
  sensor_msgs
  geometry_msgs
)

include_directories(include)

add_executable(bumpgo
  src/br2_fsm_bumpgo_cpp/BumpGoNode.cpp
  src/bumpgo_main.cpp
)
ament_target_dependencies(bumpgo ${dependencies})

install(TARGETS
  bumpgo
  ARCHIVE DESTINATION lib
  LIBRARY DESTINATION lib
  RUNTIME DESTINATION lib/${PROJECT_NAME}
)

install(DIRECTORY launch DESTINATION share/${PROJECT_NAME})

if(BUILD_TESTING)
  find_package(ament_lint_auto REQUIRED)
  ament_lint_auto_find_test_dependencies()

  set(ament_cmake_cpplint_FOUND TRUE)
  ament_lint_auto_find_test_dependencies()
endif()

ament_package()
    \end{minted}
    \end{tcolorbox}
  \normalsize

 \footnotesize
\begin{tcolorbox}[sharp corners, colframe=gray!80, colback=LightGray, left=0pt, top=0pt, bottom=0pt, title=\texttt{br2\_fsm\_bumpgo\_cpp/launch/bump\_and\_go.launch.py}]
  \begin{minted}[
    framesep=2mm,
    baselinestretch=0.8,
    bgcolor=LightGray,
    fontsize=\scriptsize
  ]{Python}
# Copyright 2021 Intelligent Robotics Lab
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

from launch import LaunchDescription
from launch_ros.actions import Node


def generate_launch_description():

    bumpgo_cmd = Node(package='br2_fsm_bumpgo_cpp',
                      executable='bumpgo',
                      output='screen',
                      parameters=[{
                        'use_sim_time': True
                      }],
                      remappings=[
                        ('input_scan', '/scan_raw'),
                        ('output_vel', '/nav_vel')
                      ])

    ld = LaunchDescription()
    ld.add_action(bumpgo_cmd)

    return ld
    \end{minted}
    \end{tcolorbox}
  \normalsize

 \footnotesize
\begin{tcolorbox}[sharp corners, colframe=gray!80, colback=LightGray, left=0pt, top=0pt, bottom=0pt, title=\texttt{br2\_fsm\_bumpgo\_cpp/package.xml}]
  \begin{minted}[
    framesep=2mm,
    baselinestretch=0.8,
    bgcolor=LightGray,
    fontsize=\scriptsize
  ]{CPP}
<?xml version="1.0"?>
<?xml-model href="http://download.ros.org/schema/package_format3.xsd" schematypens="http://www.w3.org/2001/XMLSchema"?>
<package format="3">
  <name>br2_fsm_bumpgo_cpp</name>
  <version>0.1.0</version>
  <description>Bump and Go behavior based on Finite State Machines</description>
  <maintainer email="fmrico@gmail.com">fmrico</maintainer>
  <license>Apache 2.0</license>

  <buildtool_depend>ament_cmake</buildtool_depend>

  <depend>rclcpp</depend>
  <depend>geometry_msgs</depend>
  <depend>sensor_msgs</depend>

  <test_depend>ament_lint_auto</test_depend>
  <test_depend>ament_lint_common</test_depend>

  <export>
    <build_type>ament_cmake</build_type>
  </export>
</package>
    \end{minted}
    \end{tcolorbox}
  \normalsize

 \footnotesize
\begin{tcolorbox}[sharp corners, colframe=gray!80, colback=LightGray, left=0pt, top=0pt, bottom=0pt, title=\texttt{br2\_fsm\_bumpgo\_cpp/include/br2\_fsm\_bumpgo\_cpp/BumpGoNode.hpp}]
  \begin{minted}[
    framesep=2mm,
    baselinestretch=0.8,
    bgcolor=LightGray,
    fontsize=\scriptsize
  ]{CPP}
// Copyright 2021 Intelligent Robotics Lab
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

#ifndef BR2_BT_BUMPGO__BUMPGONODE_HPP_
#define BR2_BT_BUMPGO__BUMPGONODE_HPP_

#include "sensor_msgs/msg/laser_scan.hpp"
#include "geometry_msgs/msg/twist.hpp"

#include "rclcpp/rclcpp.hpp"

namespace br2_fsm_bumpgo_cpp
{

using namespace std::chrono_literals;

class BumpGoNode : public rclcpp::Node
{
public:
  BumpGoNode();

private:
  void scan_callback(sensor_msgs::msg::LaserScan::UniquePtr msg);
  void control_cycle();

  static const int FORWARD = 0;
  static const int BACK = 1;
  static const int TURN = 2;
  static const int STOP = 3;
  int state_;
  rclcpp::Time state_ts_;

  void go_state(int new_state);
  bool check_forward_2_back();
  bool check_forward_2_stop();
  bool check_back_2_turn();
  bool check_turn_2_forward();
  bool check_stop_2_forward();

  const rclcpp::Duration TURNING_TIME {2s};
  const rclcpp::Duration BACKING_TIME {2s};
  const rclcpp::Duration SCAN_TIMEOUT {1s};

  static constexpr float SPEED_LINEAR = 0.3f;
  static constexpr float SPEED_ANGULAR = 0.3f;
  static constexpr float OBSTACLE_DISTANCE = 1.0f;

  rclcpp::Subscription<sensor_msgs::msg::LaserScan>::SharedPtr scan_sub_;
  rclcpp::Publisher<geometry_msgs::msg::Twist>::SharedPtr vel_pub_;
  rclcpp::TimerBase::SharedPtr timer_;

  sensor_msgs::msg::LaserScan::UniquePtr last_scan_;
};

} // namespace br2_fsm_bumpgo_cpp

#endif // BR2_BT_BUMPGO__BUMPGONODE_HPP_
    \end{minted}
    \end{tcolorbox}
  \normalsize

 \footnotesize
\begin{tcolorbox}[sharp corners, colframe=gray!80, colback=LightGray, left=0pt, top=0pt, bottom=0pt, title=\texttt{br2\_fsm\_bumpgo\_cpp/src/bumpgo\_main.cpp}]
  \begin{minted}[
    framesep=2mm,
    baselinestretch=0.8,
    bgcolor=LightGray,
    fontsize=\scriptsize
  ]{CPP}
// Copyright 2021 Intelligent Robotics Lab
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

#include <memory>

#include "br2_fsm_bumpgo_cpp/BumpGoNode.hpp"
#include "rclcpp/rclcpp.hpp"

int main(int argc, char * argv[])
{
  rclcpp::init(argc, argv);

  auto bumpgo_node = std::make_shared<br2_fsm_bumpgo_cpp::BumpGoNode>();
  rclcpp::spin(bumpgo_node);

  rclcpp::shutdown();

  return 0;
}
    \end{minted}
    \end{tcolorbox}
  \normalsize

 \footnotesize
\begin{tcolorbox}[sharp corners, colframe=gray!80, colback=LightGray, left=0pt, top=0pt, bottom=0pt, title=\texttt{br2\_fsm\_bumpgo\_cpp/src/br2\_fsm\_bumpgo\_cpp/BumpGoNode.cpp}]
  \begin{minted}[
    framesep=2mm,
    baselinestretch=0.8,
    bgcolor=LightGray,
    fontsize=\scriptsize
  ]{CPP}
// Copyright 2021 Intelligent Robotics Lab
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

#include <utility>
#include "br2_fsm_bumpgo_cpp/BumpGoNode.hpp"

#include "sensor_msgs/msg/laser_scan.hpp"
#include "geometry_msgs/msg/twist.hpp"

#include "rclcpp/rclcpp.hpp"

namespace br2_fsm_bumpgo_cpp
{

using namespace std::chrono_literals;
using std::placeholders::_1;

BumpGoNode::BumpGoNode()
: Node("bump_go"),
  state_(FORWARD)
{
  scan_sub_ = create_subscription<sensor_msgs::msg::LaserScan>(
    "input_scan", rclcpp::SensorDataQoS(),
    std::bind(&BumpGoNode::scan_callback, this, _1));

  vel_pub_ = create_publisher<geometry_msgs::msg::Twist>("output_vel", 10);
  timer_ = create_wall_timer(50ms, std::bind(&BumpGoNode::control_cycle, this));

  state_ts_ = now();
}

void
BumpGoNode::scan_callback(sensor_msgs::msg::LaserScan::UniquePtr msg)
{
  last_scan_ = std::move(msg);
}

void
BumpGoNode::control_cycle()
{
  // Do nothing until the first sensor read
  if (last_scan_ == nullptr)
    return;

  geometry_msgs::msg::Twist out_vel;

  switch (state_) {
    case FORWARD:
      out_vel.linear.x = SPEED_LINEAR;

      if (check_forward_2_stop())
        go_state(STOP);
      if (check_forward_2_back())
        go_state(BACK);

      break;
    case BACK:
      out_vel.linear.x = -SPEED_LINEAR;

      if (check_back_2_turn())
        go_state(TURN);

      break;
    case TURN:
      out_vel.angular.z = SPEED_ANGULAR;

      if (check_turn_2_forward())
        go_state(FORWARD);

      break;
    case STOP:
      if (check_stop_2_forward())
        go_state(FORWARD);
      break;
  }

  vel_pub_->publish(out_vel);
}

void
BumpGoNode::go_state(int new_state)
{
  state_ = new_state;
  state_ts_ = now();
}

bool 
BumpGoNode::check_forward_2_back() 
{
  // going forward when deteting an obstacle
  // at 0.5 meters with the front laser read
  size_t pos = last_scan_->ranges.size() / 2;
  return last_scan_->ranges[pos] < OBSTACLE_DISTANCE;
}
  
bool
BumpGoNode::check_forward_2_stop()
{
  // Stop if no sensor readings for 1 second
  auto elapsed = now() - rclcpp::Time(last_scan_->header.stamp);
  return elapsed > SCAN_TIMEOUT;
}

bool 
BumpGoNode::check_stop_2_forward()
{
  // Going forward if sensor readings are available
  // again
  auto elapsed = now() - rclcpp::Time(last_scan_->header.stamp);
  return elapsed < SCAN_TIMEOUT;
}

bool
BumpGoNode::check_back_2_turn()
{
  // Going back for 2 seconds
  return (now() - state_ts_) > BACKING_TIME;
}

bool
BumpGoNode::check_turn_2_forward()
{
  // Turning for 2 seconds
  return (now() - state_ts_) > TURNING_TIME;
}

} // namespace br2_fsm_bumpgo_cpp     \end{minted}
    \end{tcolorbox}
  \normalsize



\appendix

\chapter[Source Code]{Source Code}
\label{cap:source}
Complete list of source code used in the book, also available in:

\vspace{0.5cm}
\large
\texttt{https://github.com/fmrico/book\_ros2}
\normalsize
)
\section{Package \texttt{br2\_fsm\_bumpgo\_py}}
\label{sec:anex:br2_fsm_bumpgo_py}

 \footnotesize
\begin{tcolorbox}[sharp corners, colframe=gray!80, colback=LightGray, left=0pt, top=0pt, bottom=0pt, title=Package \texttt{br2\_fsm\_bumpgo\_py}]
  \begin{minted}[
    framesep=2mm,
    baselinestretch=0.8,
    bgcolor=LightGreen,
    fontsize=\scriptsize
  ]{console}
br2_fsm_bumpgo_py
├── br2_fsm_bumpgo_py
│   ├── bump_go_main.py
│   ├── __init__.py
│   └── __pycache__
│       ├── bump_go_main.cpython-38.pyc
│       └── __init__.cpython-38.pyc
├── launch
│   └── bump_and_go.launch.py
├── package.xml
├── resource
│   └── br2_fsm_bumpgo_py
├── setup.cfg
├── setup.py
└── test
    ├── __pycache__
    │   ├── test_copyright.cpython-38-pytest-6.2.3.pyc
    │   ├── test_flake8.cpython-38-pytest-6.2.3.pyc
    │   └── test_pep257.cpython-38-pytest-6.2.3.pyc
    ├── test_copyright.py
    ├── test_flake8.py
    └── test_pep257.py    \end{minted}
    \end{tcolorbox}
  \normalsize

 \footnotesize
\begin{tcolorbox}[sharp corners, colframe=gray!80, colback=LightGray, left=0pt, top=0pt, bottom=0pt, title=\texttt{br2\_fsm\_bumpgo\_py/launch/bump\_and\_go.launch.py}]
  \begin{minted}[
    framesep=2mm,
    baselinestretch=0.8,
    bgcolor=LightGray,
    fontsize=\scriptsize
  ]{Python}
# Copyright 2021 Intelligent Robotics Lab
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

from launch import LaunchDescription
from launch_ros.actions import Node


def generate_launch_description():

    kobuki_cmd = Node(package='br2_fsm_bumpgo_py',
                      executable='bump_go_main',
                      output='screen',
                      parameters=[{
                        'use_sim_time': True
                      }],
                      remappings=[
                        ('input_scan', '/scan_raw'),
                        ('output_vel', '/nav_vel')
                      ])

    ld = LaunchDescription()
    ld.add_action(kobuki_cmd)

    return ld
    \end{minted}
    \end{tcolorbox}
  \normalsize

 \footnotesize
\begin{tcolorbox}[sharp corners, colframe=gray!80, colback=LightGray, left=0pt, top=0pt, bottom=0pt, title=\texttt{br2\_fsm\_bumpgo\_py/package.xml}]
  \begin{minted}[
    framesep=2mm,
    baselinestretch=0.8,
    bgcolor=LightGray,
    fontsize=\scriptsize
  ]{XML}
<?xml version="1.0"?>
<?xml-model href="http://download.ros.org/schema/package_format3.xsd" schematypens="http://www.w3.org/2001/XMLSchema"?>
<package format="3">
  <name>br2_fsm_bumpgo_py</name>
  <version>0.0.0</version>
  <description>TODO: Package description</description>
  <maintainer email="fmrico@gmail.com">fmrico</maintainer>
  <license>TODO: License declaration</license>

  <depend>rclcpy</depend>
  <depend>sensor_msgs</depend>
  <depend>geometry_msgs</depend>

  <test_depend>ament_copyright</test_depend>
  <test_depend>ament_flake8</test_depend>
  <test_depend>ament_pep257</test_depend>
  <test_depend>python3-pytest</test_depend>

  <export>
    <build_type>ament_python</build_type>
  </export>
</package>
    \end{minted}
    \end{tcolorbox}
  \normalsize

 \footnotesize
\begin{tcolorbox}[sharp corners, colframe=gray!80, colback=LightGray, left=0pt, top=0pt, bottom=0pt, title=\texttt{br2\_fsm\_bumpgo\_py/test/test\_flake8.py}]
  \begin{minted}[
    framesep=2mm,
    baselinestretch=0.8,
    bgcolor=LightGray,
    fontsize=\scriptsize
  ]{Python}
# Copyright 2017 Open Source Robotics Foundation, Inc.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

from ament_flake8.main import main_with_errors
import pytest


@pytest.mark.flake8
@pytest.mark.linter
def test_flake8():
    rc, errors = main_with_errors(argv=[])
    assert rc == 0, \
        'Found %d code style errors / warnings:\n' % len(errors) + \
        '\n'.join(errors)
    \end{minted}
    \end{tcolorbox}
  \normalsize

 \footnotesize
\begin{tcolorbox}[sharp corners, colframe=gray!80, colback=LightGray, left=0pt, top=0pt, bottom=0pt, title=\texttt{br2\_fsm\_bumpgo\_py/test/test\_copyright.py}]
  \begin{minted}[
    framesep=2mm,
    baselinestretch=0.8,
    bgcolor=LightGray,
    fontsize=\scriptsize
  ]{Python}
# Copyright 2015 Open Source Robotics Foundation, Inc.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

from ament_copyright.main import main
import pytest


@pytest.mark.copyright
@pytest.mark.linter
def test_copyright():
    rc = main(argv=['.', 'test'])
    assert rc == 0, 'Found errors'
    \end{minted}
    \end{tcolorbox}
  \normalsize

 \footnotesize
\begin{tcolorbox}[sharp corners, colframe=gray!80, colback=LightGray, left=0pt, top=0pt, bottom=0pt, title=\texttt{br2\_fsm\_bumpgo\_py/test/test\_pep257.py}]
  \begin{minted}[
    framesep=2mm,
    baselinestretch=0.8,
    bgcolor=LightGray,
    fontsize=\scriptsize
  ]{Python}
# Copyright 2015 Open Source Robotics Foundation, Inc.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

from ament_pep257.main import main
import pytest


@pytest.mark.linter
@pytest.mark.pep257
def test_pep257():
    rc = main(argv=['.', 'test'])
    assert rc == 0, 'Found code style errors / warnings'
    \end{minted}
    \end{tcolorbox}
  \normalsize

 \footnotesize
\begin{tcolorbox}[sharp corners, colframe=gray!80, colback=LightGray, left=0pt, top=0pt, bottom=0pt, title=\texttt{br2\_fsm\_bumpgo\_py/br2\_fsm\_bumpgo\_py/\_\_init\_\_.py}]
  \begin{minted}[
    framesep=2mm,
    baselinestretch=0.8,
    bgcolor=LightGray,
    fontsize=\scriptsize
  ]{Python}
    \end{minted}
    \end{tcolorbox}
  \normalsize

 \footnotesize
\begin{tcolorbox}[sharp corners, colframe=gray!80, colback=LightGray, left=0pt, top=0pt, bottom=0pt, title=\texttt{br2\_fsm\_bumpgo\_py/br2\_fsm\_bumpgo\_py/bump\_go\_main.py}]
  \begin{minted}[
    framesep=2mm,
    baselinestretch=0.8,
    bgcolor=LightGray,
    fontsize=\scriptsize
  ]{Python}
import rclpy

from rclpy.duration import Duration
from rclpy.node import Node
from rclpy.qos import qos_profile_sensor_data
from rclpy.time import Time

from geometry_msgs.msg import Twist
from sensor_msgs.msg import LaserScan


class BumpGoNode(Node):
    def __init__(self):
        super().__init__('bump_go')

        self.FORWARD = 0
        self.BACK = 1
        self.TURN = 2
        self.STOP = 3
        self.state = self.FORWARD
        self.state_ts = self.get_clock().now()

        self.TURNING_TIME = 2.0
        self.BACKING_TIME = 2.0
        self.SCAN_TIMEOUT = 1.0

        self.SPEED_LINEAR = 0.3
        self.SPEED_ANGULAR = 0.3
        self.OBSTACLE_DISTANCE = 1.0

        self.last_scan = None

        self.scan_sub = self.create_subscription(
            LaserScan,
            'input_scan',
            self.scan_callback,
            qos_profile_sensor_data)

        self.vel_pub = self.create_publisher(Twist, 'output_vel', 10)
        self.timer = self.create_timer(0.05, self.control_cycle)

    def scan_callback(self, msg):
        self.last_scan = msg

    def control_cycle(self):
        if self.last_scan is None:
            return

        out_vel = Twist()

        if self.state == self.FORWARD:
          out_vel.linear.x = self.SPEED_LINEAR

          if self.check_forward_2_stop():
            self.go_state(self.STOP)
          if self.check_forward_2_back():
            self.go_state(self.BACK)

        elif self.state == self.BACK:
          out_vel.linear.x = -self.SPEED_LINEAR

          if self.check_back_2_turn():
            self.go_state(self.TURN)

        elif self.state == self.TURN:
          out_vel.angular.z = self.SPEED_ANGULAR

          if self.check_turn_2_forward():
            self.go_state(self.FORWARD)

        elif self.state == self.STOP:
          if self.check_stop_2_forward():
            self.go_state(self.FORWARD)

        self.vel_pub.publish(out_vel)

    def go_state(self, new_state):
        self.state = new_state
        self.state_ts = self.get_clock().now()

    def check_forward_2_back(self):
        pos = round(len(self.last_scan.ranges) / 2)
        return self.last_scan.ranges[pos] < self.OBSTACLE_DISTANCE

    def check_forward_2_stop(self):
        elapsed = self.get_clock().now() - Time.from_msg(self.last_scan.header.stamp)
        return elapsed > Duration(seconds=self.SCAN_TIMEOUT)

    def check_stop_2_forward(self):
        elapsed = self.get_clock().now() - Time.from_msg(self.last_scan.header.stamp)
        return elapsed < Duration(seconds=self.SCAN_TIMEOUT)

    def check_back_2_turn(self):
        elapsed = self.get_clock().now() - self.state_ts
        return elapsed > Duration(seconds=self.BACKING_TIME)

    def check_turn_2_forward(self):
        elapsed = self.get_clock().now() - self.state_ts
        return elapsed > Duration(seconds=self.TURNING_TIME)

def main(args=None):
    rclpy.init(args=args)

    bump_go_node = BumpGoNode()

    rclpy.spin(bump_go_node)

    bump_go_node.destroy_node()
    rclpy.shutdown()

if __name__ == '__main__':
    main()
    \end{minted}
    \end{tcolorbox}
  \normalsize

 \footnotesize
\begin{tcolorbox}[sharp corners, colframe=gray!80, colback=LightGray, left=0pt, top=0pt, bottom=0pt, title=\texttt{br2\_fsm\_bumpgo\_py/setup.py}]
  \begin{minted}[
    framesep=2mm,
    baselinestretch=0.8,
    bgcolor=LightGray,
    fontsize=\scriptsize
  ]{Python}
import os
from glob import glob

from setuptools import setup

package_name = 'br2_fsm_bumpgo_py'

setup(
    name=package_name,
    version='0.0.0',
    packages=[package_name],
    data_files=[
        ('share/ament_index/resource_index/packages',
            ['resource/' + package_name]),
        ('share/' + package_name, ['package.xml']),
        (os.path.join('share', package_name, 'launch'), glob('launch/*.launch.py'))
    ],
    install_requires=['setuptools'],
    zip_safe=True,
    maintainer='fmrico',
    maintainer_email='fmrico@gmail.com',
    description='TODO: Package description',
    license='TODO: License declaration',
    tests_require=['pytest'],
    entry_points={
        'console_scripts': [
          'bump_go_main = br2_fsm_bumpgo_py.bump_go_main:main'
        ],
    },
)
    \end{minted}
    \end{tcolorbox}
  \normalsize



\appendix

\chapter[Source Code]{Source Code}
\label{cap:source}
Complete list of source code used in the book, also available in:

\vspace{0.5cm}
\large
\texttt{https://github.com/fmrico/book\_ros2}
\normalsize
)
\section{Package \texttt{br2\_tf2\_detector}}
\label{sec:anex:br2_tf2_detector}

 \footnotesize
\begin{tcolorbox}[sharp corners, colframe=gray!80, colback=LightGray, left=0pt, top=0pt, bottom=0pt, title=Package \texttt{br2\_tf2\_detector}]
  \begin{minted}[
    framesep=2mm,
    baselinestretch=0.8,
    bgcolor=LightGreen,
    fontsize=\scriptsize
  ]{console}
br2_tf2_detector
├── CMakeLists.txt
├── include
│   └── br2_tf2_detector
│       ├── ObstacleDetectorImprovedNode.hpp
│       ├── ObstacleDetectorNode.hpp
│       └── ObstacleMonitorNode.hpp
├── launch
│   ├── detector_basic.launch.py
│   └── detector_improved.launch.py
├── package.xml
└── src
    ├── br2_tf2_detector
    │   ├── ObstacleDetectorImprovedNode.cpp
    │   ├── ObstacleDetectorNode.cpp
    │   └── ObstacleMonitorNode.cpp
    ├── detector_improved_main.cpp
    └── detector_main.cpp    \end{minted}
    \end{tcolorbox}
  \normalsize

 \footnotesize
\begin{tcolorbox}[sharp corners, colframe=gray!80, colback=LightGray, left=0pt, top=0pt, bottom=0pt, title=\texttt{br2\_tf2\_detector/CMakeLists.txt}]
  \begin{minted}[
    framesep=2mm,
    baselinestretch=0.8,
    bgcolor=LightGray,
    fontsize=\scriptsize
  ]{CMake}
cmake_minimum_required(VERSION 3.5)
project(br2_tf2_detector)

set(CMAKE_CXX_STANDARD 17)

# find dependencies
find_package(ament_cmake REQUIRED)
find_package(rclcpp REQUIRED)
find_package(tf2_ros REQUIRED)
find_package(geometry_msgs REQUIRED)
find_package(sensor_msgs REQUIRED)
find_package(visualization_msgs REQUIRED)

set(dependencies
    rclcpp
    tf2_ros
    geometry_msgs
    sensor_msgs
    visualization_msgs
)

include_directories(include)

add_library(${PROJECT_NAME} SHARED
  src/br2_tf2_detector/ObstacleDetectorNode.cpp
  src/br2_tf2_detector/ObstacleMonitorNode.cpp
  src/br2_tf2_detector/ObstacleDetectorImprovedNode.cpp
)
ament_target_dependencies(${PROJECT_NAME} ${dependencies})

add_executable(detector src/detector_main.cpp)
ament_target_dependencies(detector ${dependencies})
target_link_libraries(detector ${PROJECT_NAME})

add_executable(detector_improved src/detector_improved_main.cpp)
ament_target_dependencies(detector_improved ${dependencies})
target_link_libraries(detector_improved ${PROJECT_NAME})

install(TARGETS
  ${PROJECT_NAME}
  detector
  detector_improved
  ARCHIVE DESTINATION lib
  LIBRARY DESTINATION lib
  RUNTIME DESTINATION lib/${PROJECT_NAME}
)

install(DIRECTORY launch DESTINATION share/${PROJECT_NAME})

if(BUILD_TESTING)
  find_package(ament_lint_auto REQUIRED)
  ament_lint_auto_find_test_dependencies()
endif()

ament_package()
    \end{minted}
    \end{tcolorbox}
  \normalsize

 \footnotesize
\begin{tcolorbox}[sharp corners, colframe=gray!80, colback=LightGray, left=0pt, top=0pt, bottom=0pt, title=\texttt{br2\_tf2\_detector/launch/detector\_improved.launch.py}]
  \begin{minted}[
    framesep=2mm,
    baselinestretch=0.8,
    bgcolor=LightGray,
    fontsize=\scriptsize
  ]{Python}
# Copyright 2021 Intelligent Robotics Lab
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

from launch import LaunchDescription
from launch_ros.actions import Node


def generate_launch_description():

    detector_cmd = Node(package='br2_tf2_detector',
                        executable='detector_improved',
                        output='screen',
                        parameters=[{
                          'use_sim_time': True
                        }],
                        remappings=[
                          ('input_scan', '/scan_raw')
                        ])

    ld = LaunchDescription()
    ld.add_action(detector_cmd)

    return ld
    \end{minted}
    \end{tcolorbox}
  \normalsize

 \footnotesize
\begin{tcolorbox}[sharp corners, colframe=gray!80, colback=LightGray, left=0pt, top=0pt, bottom=0pt, title=\texttt{br2\_tf2\_detector/launch/detector\_basic.launch.py}]
  \begin{minted}[
    framesep=2mm,
    baselinestretch=0.8,
    bgcolor=LightGray,
    fontsize=\scriptsize
  ]{Python}
# Copyright 2021 Intelligent Robotics Lab
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

from launch import LaunchDescription
from launch_ros.actions import Node


def generate_launch_description():

    detector_cmd = Node(package='br2_tf2_detector',
                        executable='detector',
                        output='screen',
                        parameters=[{
                          'use_sim_time': True
                        }],
                        remappings=[
                          ('input_scan', '/scan_raw')
                        ])

    ld = LaunchDescription()
    ld.add_action(detector_cmd)

    return ld
    \end{minted}
    \end{tcolorbox}
  \normalsize

 \footnotesize
\begin{tcolorbox}[sharp corners, colframe=gray!80, colback=LightGray, left=0pt, top=0pt, bottom=0pt, title=\texttt{br2\_tf2\_detector/package.xml}]
  \begin{minted}[
    framesep=2mm,
    baselinestretch=0.8,
    bgcolor=LightGray,
    fontsize=\scriptsize
  ]{XML}
<?xml version="1.0"?>
<?xml-model href="http://download.ros.org/schema/package_format3.xsd" schematypens="http://www.w3.org/2001/XMLSchema"?>
<package format="3">
  <name>br2_tf2_detector</name>
  <version>0.0.0</version>
  <description>TODO: Package description</description>
  <maintainer email="fmrico@gmail.com">fmrico</maintainer>
  <license>TODO: License declaration</license>

  <buildtool_depend>ament_cmake</buildtool_depend>

  <depend>rclcpp</depend>
  <depend>tf2_ros</depend>
  <depend>geometry_msgs</depend>
  <depend>sensor_msgs</depend>

  <test_depend>ament_lint_auto</test_depend>
  <test_depend>ament_lint_common</test_depend>

  <export>
    <build_type>ament_cmake</build_type>
  </export>
</package>
    \end{minted}
    \end{tcolorbox}
  \normalsize

 \footnotesize
\begin{tcolorbox}[sharp corners, colframe=gray!80, colback=LightGray, left=0pt, top=0pt, bottom=0pt, title=\texttt{br2\_tf2\_detector/include/br2\_tf2\_detector/ObstacleDetectorImprovedNode.hpp}]
  \begin{minted}[
    framesep=2mm,
    baselinestretch=0.8,
    bgcolor=LightGray,
    fontsize=\scriptsize
  ]{CPP}
// Copyright 2021 Intelligent Robotics Lab
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

#ifndef BR2_TF2_DETECTOR__OBSTACLEDETECTORIMPROVEDNODE_HPP_
#define BR2_TF2_DETECTOR__OBSTACLEDETECTORIMPROVEDNODE_HPP_

#include <tf2_ros/static_transform_broadcaster.h>
#include <tf2_ros/buffer.h>
#include <tf2_ros/transform_listener.h>

#include <memory>

#include "sensor_msgs/msg/laser_scan.hpp"

#include "rclcpp/rclcpp.hpp"

namespace br2_tf2_detector
{

class ObstacleDetectorImprovedNode : public rclcpp::Node
{
public:
  ObstacleDetectorImprovedNode();

private:
  void scan_callback(sensor_msgs::msg::LaserScan::UniquePtr msg);

  rclcpp::Subscription<sensor_msgs::msg::LaserScan>::SharedPtr scan_sub_;
  std::shared_ptr<tf2_ros::StaticTransformBroadcaster> tf_broadcaster_;

  tf2::BufferCore tf_buffer_;
  tf2_ros::TransformListener tf_listener_;
};

}  // namespace br2_tf2_detector
#endif  // BR2_TF2_DETECTOR__OBSTACLEDETECTORIMPROVEDNODE_HPP_
    \end{minted}
    \end{tcolorbox}
  \normalsize

 \footnotesize
\begin{tcolorbox}[sharp corners, colframe=gray!80, colback=LightGray, left=0pt, top=0pt, bottom=0pt, title=\texttt{br2\_tf2\_detector/include/br2\_tf2\_detector/ObstacleMonitorNode.hpp}]
  \begin{minted}[
    framesep=2mm,
    baselinestretch=0.8,
    bgcolor=LightGray,
    fontsize=\scriptsize
  ]{CPP}
// Copyright 2021 Intelligent Robotics Lab
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

#ifndef BR2_TF2_DETECTOR__OBSTACLEMONITORNODE_HPP_
#define BR2_TF2_DETECTOR__OBSTACLEMONITORNODE_HPP_

#include <tf2_ros/buffer.h>
#include <tf2_ros/transform_listener.h>

#include <memory>


#include "sensor_msgs/msg/laser_scan.hpp"
#include "visualization_msgs/msg/marker.hpp"

#include "rclcpp/rclcpp.hpp"

namespace br2_tf2_detector
{

class ObstacleMonitorNode : public rclcpp::Node
{
public:
  ObstacleMonitorNode();

private:
  void control_cycle();
  rclcpp::TimerBase::SharedPtr timer_;

  tf2::BufferCore tf_buffer_;
  tf2_ros::TransformListener tf_listener_;

  rclcpp::Publisher<visualization_msgs::msg::Marker>::SharedPtr marker_pub_;
};

}  // namespace br2_tf2_detector
#endif  // BR2_TF2_DETECTOR__OBSTACLEMONITORNODE_HPP_
    \end{minted}
    \end{tcolorbox}
  \normalsize

 \footnotesize
\begin{tcolorbox}[sharp corners, colframe=gray!80, colback=LightGray, left=0pt, top=0pt, bottom=0pt, title=\texttt{br2\_tf2\_detector/include/br2\_tf2\_detector/ObstacleDetectorNode.hpp}]
  \begin{minted}[
    framesep=2mm,
    baselinestretch=0.8,
    bgcolor=LightGray,
    fontsize=\scriptsize
  ]{CPP}
// Copyright 2021 Intelligent Robotics Lab
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

#ifndef BR2_TF2_DETECTOR__OBSTACLEDETECTORNODE_HPP_
#define BR2_TF2_DETECTOR__OBSTACLEDETECTORNODE_HPP_

#include <tf2_ros/static_transform_broadcaster.h>

#include <memory>

#include "sensor_msgs/msg/laser_scan.hpp"

#include "rclcpp/rclcpp.hpp"

namespace br2_tf2_detector
{

class ObstacleDetectorNode : public rclcpp::Node
{
public:
  ObstacleDetectorNode();

private:
  void scan_callback(sensor_msgs::msg::LaserScan::UniquePtr msg);

  rclcpp::Subscription<sensor_msgs::msg::LaserScan>::SharedPtr scan_sub_;
  std::shared_ptr<tf2_ros::StaticTransformBroadcaster> tf_broadcaster_;
};

}  // namespace br2_tf2_detector
#endif  // BR2_TF2_DETECTOR__OBSTACLEDETECTORNODE_HPP_
    \end{minted}
    \end{tcolorbox}
  \normalsize

 \footnotesize
\begin{tcolorbox}[sharp corners, colframe=gray!80, colback=LightGray, left=0pt, top=0pt, bottom=0pt, title=\texttt{br2\_tf2\_detector/src/detector\_main.cpp}]
  \begin{minted}[
    framesep=2mm,
    baselinestretch=0.8,
    bgcolor=LightGray,
    fontsize=\scriptsize
  ]{CPP}
// Copyright 2021 Intelligent Robotics Lab
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

#include <memory>

#include "br2_tf2_detector/ObstacleDetectorNode.hpp"
#include "br2_tf2_detector/ObstacleMonitorNode.hpp"

#include "rclcpp/rclcpp.hpp"

int main(int argc, char * argv[])
{
  rclcpp::init(argc, argv);

  auto obstacle_detector = std::make_shared<br2_tf2_detector::ObstacleDetectorNode>();
  auto obstacle_monitor = std::make_shared<br2_tf2_detector::ObstacleMonitorNode>();

  rclcpp::executors::SingleThreadedExecutor executor;
  executor.add_node(obstacle_detector->get_node_base_interface());
  executor.add_node(obstacle_monitor->get_node_base_interface());

  executor.spin();

  rclcpp::shutdown();
  return 0;
}
    \end{minted}
    \end{tcolorbox}
  \normalsize

 \footnotesize
\begin{tcolorbox}[sharp corners, colframe=gray!80, colback=LightGray, left=0pt, top=0pt, bottom=0pt, title=\texttt{br2\_tf2\_detector/src/detector\_improved\_main.cpp}]
  \begin{minted}[
    framesep=2mm,
    baselinestretch=0.8,
    bgcolor=LightGray,
    fontsize=\scriptsize
  ]{CPP}
// Copyright 2021 Intelligent Robotics Lab
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

#include <memory>

#include "br2_tf2_detector/ObstacleDetectorImprovedNode.hpp"
#include "br2_tf2_detector/ObstacleMonitorNode.hpp"

#include "rclcpp/rclcpp.hpp"

int main(int argc, char * argv[])
{
  rclcpp::init(argc, argv);

  auto obstacle_detector = std::make_shared<br2_tf2_detector::ObstacleDetectorImprovedNode>();
  auto obstacle_monitor = std::make_shared<br2_tf2_detector::ObstacleMonitorNode>();

  rclcpp::executors::SingleThreadedExecutor executor;
  executor.add_node(obstacle_detector->get_node_base_interface());
  executor.add_node(obstacle_monitor->get_node_base_interface());

  executor.spin();

  rclcpp::shutdown();
  return 0;
}
    \end{minted}
    \end{tcolorbox}
  \normalsize

 \footnotesize
\begin{tcolorbox}[sharp corners, colframe=gray!80, colback=LightGray, left=0pt, top=0pt, bottom=0pt, title=\texttt{br2\_tf2\_detector/src/br2\_tf2\_detector/ObstacleMonitorNode.cpp}]
  \begin{minted}[
    framesep=2mm,
    baselinestretch=0.8,
    bgcolor=LightGray,
    fontsize=\scriptsize
  ]{CPP}
// Copyright 2021 Intelligent Robotics Lab
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

#include <tf2/transform_datatypes.h>
#include <tf2/LinearMath/Quaternion.h>
#include <tf2_geometry_msgs/tf2_geometry_msgs.h>

#include <memory>

#include "br2_tf2_detector/ObstacleMonitorNode.hpp"

#include "geometry_msgs/msg/transform_stamped.hpp"

#include "rclcpp/rclcpp.hpp"

namespace br2_tf2_detector
{

using namespace std::chrono_literals;

ObstacleMonitorNode::ObstacleMonitorNode()
: Node("obstacle_monitor"),
  tf_buffer_(),
  tf_listener_(tf_buffer_)
{
  marker_pub_ = create_publisher<visualization_msgs::msg::Marker>("obstacle_marker", 1);

  timer_ = create_wall_timer(
    500ms, std::bind(&ObstacleMonitorNode::control_cycle, this));
}

void
ObstacleMonitorNode::control_cycle()
{
  geometry_msgs::msg::TransformStamped robot2obstacle;

  try {
    robot2obstacle = tf_buffer_.lookupTransform(
      "base_footprint", "detected_obstacle", tf2::TimePointZero);
  } catch (tf2::TransformException & ex) {
    RCLCPP_WARN(get_logger(), "Obstacle transform not found: %s", ex.what());
    return;
  }

  double x = robot2obstacle.transform.translation.x;
  double y = robot2obstacle.transform.translation.y;
  double z = robot2obstacle.transform.translation.z;
  double theta = atan2(y, x);

  RCLCPP_INFO(
    get_logger(), "Obstacle detected at (%lf m, %lf m, , %lf m) = %lf rads",
    x, y, z, theta);

  visualization_msgs::msg::Marker obstacle_arrow;
  obstacle_arrow.header.frame_id = "base_footprint";
  obstacle_arrow.header.stamp = now();
  obstacle_arrow.type = visualization_msgs::msg::Marker::ARROW;
  obstacle_arrow.action = visualization_msgs::msg::Marker::ADD;
  obstacle_arrow.lifetime = rclcpp::Duration(1s);

  geometry_msgs::msg::Point start;
  start.x = 0.0;
  start.y = 0.0;
  start.z = 0.0;
  geometry_msgs::msg::Point end;
  end.x = x;
  end.y = y;
  end.z = z;
  obstacle_arrow.points = {start, end};

  obstacle_arrow.color.r = 1.0;
  obstacle_arrow.color.g = 0.0;
  obstacle_arrow.color.b = 0.0;
  obstacle_arrow.color.a = 1.0;

  obstacle_arrow.scale.x = 0.02;
  obstacle_arrow.scale.y = 0.1;
  obstacle_arrow.scale.z = 0.1;


  marker_pub_->publish(obstacle_arrow);
}

}  // namespace br2_tf2_detector
    \end{minted}
    \end{tcolorbox}
  \normalsize

 \footnotesize
\begin{tcolorbox}[sharp corners, colframe=gray!80, colback=LightGray, left=0pt, top=0pt, bottom=0pt, title=\texttt{br2\_tf2\_detector/src/br2\_tf2\_detector/ObstacleDetectorNode.cpp}]
  \begin{minted}[
    framesep=2mm,
    baselinestretch=0.8,
    bgcolor=LightGray,
    fontsize=\scriptsize
  ]{CPP}
// Copyright 2021 Intelligent Robotics Lab
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

#include <memory>

#include "br2_tf2_detector/ObstacleDetectorNode.hpp"

#include "sensor_msgs/msg/laser_scan.hpp"
#include "geometry_msgs/msg/transform_stamped.hpp"

#include "rclcpp/rclcpp.hpp"

namespace br2_tf2_detector
{

using std::placeholders::_1;

ObstacleDetectorNode::ObstacleDetectorNode()
: Node("obstacle_detector")
{
  scan_sub_ = create_subscription<sensor_msgs::msg::LaserScan>(
    "input_scan", rclcpp::SensorDataQoS(),
    std::bind(&ObstacleDetectorNode::scan_callback, this, _1));

  tf_broadcaster_ = std::make_shared<tf2_ros::StaticTransformBroadcaster>(*this);
}

void
ObstacleDetectorNode::scan_callback(sensor_msgs::msg::LaserScan::UniquePtr msg)
{
  double dist = msg->ranges[msg->ranges.size() / 2];

  if (!std::isinf(dist)) {
    geometry_msgs::msg::TransformStamped detection_tf;

    detection_tf.header = msg->header;
    detection_tf.child_frame_id = "detected_obstacle";
    detection_tf.transform.translation.x = msg->ranges[msg->ranges.size() / 2];

    tf_broadcaster_->sendTransform(detection_tf);
  }
}

}  // namespace br2_tf2_detector
    \end{minted}
    \end{tcolorbox}
  \normalsize

 \footnotesize
\begin{tcolorbox}[sharp corners, colframe=gray!80, colback=LightGray, left=0pt, top=0pt, bottom=0pt, title=\texttt{br2\_tf2\_detector/src/br2\_tf2\_detector/ObstacleDetectorImprovedNode.cpp}]
  \begin{minted}[
    framesep=2mm,
    baselinestretch=0.8,
    bgcolor=LightGray,
    fontsize=\scriptsize
  ]{CPP}
// Copyright 2021 Intelligent Robotics Lab
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

#include <tf2/transform_datatypes.h>
#include <tf2/LinearMath/Quaternion.h>
#include <tf2_geometry_msgs/tf2_geometry_msgs.h>

#include <memory>

#include "br2_tf2_detector/ObstacleDetectorImprovedNode.hpp"

#include "sensor_msgs/msg/laser_scan.hpp"
#include "geometry_msgs/msg/transform_stamped.hpp"

#include "rclcpp/rclcpp.hpp"

namespace br2_tf2_detector
{

using std::placeholders::_1;
using namespace std::chrono_literals;

ObstacleDetectorImprovedNode::ObstacleDetectorImprovedNode()
: Node("obstacle_detector_improved"),
  tf_buffer_(),
  tf_listener_(tf_buffer_)
{
  scan_sub_ = create_subscription<sensor_msgs::msg::LaserScan>(
    "input_scan", rclcpp::SensorDataQoS(),
    std::bind(&ObstacleDetectorImprovedNode::scan_callback, this, _1));

  tf_broadcaster_ = std::make_shared<tf2_ros::StaticTransformBroadcaster>(*this);
}

void
ObstacleDetectorImprovedNode::scan_callback(sensor_msgs::msg::LaserScan::UniquePtr msg)
{
  double dist = msg->ranges[msg->ranges.size() / 2];

  if (!std::isinf(dist)) {
    tf2::Transform laser2object;
    laser2object.setOrigin(tf2::Vector3(dist, 0.0, 0.0));
    laser2object.setRotation(tf2::Quaternion(0.0, 0.0, 0.0, 1.0));

    geometry_msgs::msg::TransformStamped odom2laser_msg;
    tf2::Stamped<tf2::Transform> odom2laser;
    try {
      odom2laser_msg = tf_buffer_.lookupTransform(
        "odom", "base_laser_link", tf2::timeFromSec(rclcpp::Time(msg->header.stamp).seconds()));
      tf2::fromMsg(odom2laser_msg, odom2laser);
    } catch (tf2::TransformException & ex) {
      RCLCPP_WARN(get_logger(), "Obstacle transform not found: %s", ex.what());
      return;
    }

    tf2::Transform odom2object = odom2laser * laser2object;

    geometry_msgs::msg::TransformStamped odom2object_msg;
    odom2object_msg.transform = tf2::toMsg(odom2object);

    odom2object_msg.header.stamp = msg->header.stamp;
    odom2object_msg.header.frame_id = "odom";
    odom2object_msg.child_frame_id = "detected_obstacle";

    tf_broadcaster_->sendTransform(odom2object_msg);
  }
}

}  // namespace br2_tf2_detector
    \end{minted}
    \end{tcolorbox}
  \normalsize



\appendix

\chapter[Source Code]{Source Code}
\label{cap:source}
Complete list of source code used in the book, also available in:

\vspace{0.5cm}
\large
\texttt{https://github.com/fmrico/book\_ros2}
\normalsize
)
\section{Package \texttt{br2\_vff\_avoidance}}
\label{sec:anex:br2_vff_avoidance}

 \footnotesize
\begin{tcolorbox}[sharp corners, colframe=gray!80, colback=LightGray, left=0pt, top=0pt, bottom=0pt, title=Package \texttt{br2\_vff\_avoidance}]
  \begin{minted}[
    framesep=2mm,
    baselinestretch=0.8,
    bgcolor=LightGreen,
    fontsize=\scriptsize
  ]{console}
br2_vff_avoidance
├── CMakeLists.txt
├── include
│   └── br2_vff_avoidance
│       └── AvoidanceNode.hpp
├── launch
│   └── avoidance_vff.launch.py
├── package.xml
├── src
│   ├── avoidance_vff_main.cpp
│   └── br2_vff_avoidance
│       └── AvoidanceNode.cpp
└── tests
    ├── CMakeLists.txt
    └── vff_test.cpp    \end{minted}
    \end{tcolorbox}
  \normalsize

 \footnotesize
\begin{tcolorbox}[sharp corners, colframe=gray!80, colback=LightGray, left=0pt, top=0pt, bottom=0pt, title=\texttt{br2\_vff\_avoidance/CMakeLists.txt}]
  \begin{minted}[
    framesep=2mm,
    baselinestretch=0.8,
    bgcolor=LightGray,
    fontsize=\scriptsize
  ]{CMake}
cmake_minimum_required(VERSION 3.5)
project(br2_vff_avoidance)

set(CMAKE_CXX_STANDARD 17)
set(CMAKE_BUILD_TYPE Debug)

find_package(ament_cmake REQUIRED)
find_package(rclcpp REQUIRED)
find_package(sensor_msgs REQUIRED)
find_package(geometry_msgs REQUIRED)
find_package(visualization_msgs REQUIRED)

set(dependencies
    rclcpp
    sensor_msgs
    geometry_msgs
    visualization_msgs
)

include_directories(include)

add_library(${PROJECT_NAME} SHARED src/br2_vff_avoidance/AvoidanceNode.cpp)
ament_target_dependencies(${PROJECT_NAME} ${dependencies})

add_executable(avoidance_vff src/avoidance_vff_main.cpp)
ament_target_dependencies(avoidance_vff ${dependencies})
target_link_libraries(avoidance_vff ${PROJECT_NAME})

install(TARGETS
  ${PROJECT_NAME}
  avoidance_vff
  ARCHIVE DESTINATION lib
  LIBRARY DESTINATION lib
  RUNTIME DESTINATION lib/${PROJECT_NAME}
)

install(DIRECTORY launch DESTINATION share/${PROJECT_NAME})

if(BUILD_TESTING)
  find_package(ament_lint_auto REQUIRED)
  ament_lint_auto_find_test_dependencies()

  set(ament_cmake_cpplint_FOUND TRUE)
  ament_lint_auto_find_test_dependencies()

  find_package(ament_cmake_gtest REQUIRED)
  add_subdirectory(tests)
endif()

ament_export_dependencies(${dependencies})
ament_package()
    \end{minted}
    \end{tcolorbox}
  \normalsize

 \footnotesize
\begin{tcolorbox}[sharp corners, colframe=gray!80, colback=LightGray, left=0pt, top=0pt, bottom=0pt, title=\texttt{br2\_vff\_avoidance/launch/avoidance\_vff.launch.py}]
  \begin{minted}[
    framesep=2mm,
    baselinestretch=0.8,
    bgcolor=LightGray,
    fontsize=\scriptsize
  ]{Python}
# Copyright 2021 Intelligent Robotics Lab
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

from launch import LaunchDescription
from launch_ros.actions import Node


def generate_launch_description():

    vff_avoidance_cmd = Node(
      package='br2_vff_avoidance',
      executable='avoidance_vff',
      parameters=[{
        'use_sim_time': True
      }],
      remappings=[
        ('input_scan', '/scan_raw'),
        ('output_vel', '/nav_vel')
      ],
      output='screen'
    )

    ld = LaunchDescription()
    ld.add_action(vff_avoidance_cmd)

    return ld
    \end{minted}
    \end{tcolorbox}
  \normalsize

 \footnotesize
\begin{tcolorbox}[sharp corners, colframe=gray!80, colback=LightGray, left=0pt, top=0pt, bottom=0pt, title=\texttt{br2\_vff\_avoidance/package.xml}]
  \begin{minted}[
    framesep=2mm,
    baselinestretch=0.8,
    bgcolor=LightGray,
    fontsize=\scriptsize
  ]{XML}
<?xml version="1.0"?>
<?xml-model href="http://download.ros.org/schema/package_format3.xsd" schematypens="http://www.w3.org/2001/XMLSchema"?>
<package format="3">
  <name>br2_vff_avoidance</name>
  <version>0.1.0</version>
  <description>Mastering Reactive Behaviors in ROS2</description>
  <maintainer email="fmrico@gmail.com">fmrico</maintainer>
  <license>Apache 2.0</license>

  <buildtool_depend>ament_cmake</buildtool_depend>

  <depend>rclcpp</depend>
  <depend>geometry_msgs</depend>
  <depend>sensor_msgs</depend>
  <depend>visualization_msgs</depend>

  <test_depend>ament_lint_auto</test_depend>
  <test_depend>ament_lint_common</test_depend>
  <test_depend>ament_cmake_gtest</test_depend>

  <export>
    <build_type>ament_cmake</build_type>
  </export>
</package>
    \end{minted}
    \end{tcolorbox}
  \normalsize

 \footnotesize
\begin{tcolorbox}[sharp corners, colframe=gray!80, colback=LightGray, left=0pt, top=0pt, bottom=0pt, title=\texttt{br2\_vff\_avoidance/include/br2\_vff\_avoidance/AvoidanceNode.hpp}]
  \begin{minted}[
    framesep=2mm,
    baselinestretch=0.8,
    bgcolor=LightGray,
    fontsize=\scriptsize
  ]{CPP}
// Copyright 2021 Intelligent Robotics Lab
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

#ifndef BR2_VFF_AVOIDANCE__AVOIDANCENODE_HPP_
#define BR2_VFF_AVOIDANCE__AVOIDANCENODE_HPP_

#include <memory>
#include <vector>

#include "geometry_msgs/msg/twist.hpp"
#include "sensor_msgs/msg/laser_scan.hpp"
#include "visualization_msgs/msg/marker_array.hpp"

#include "rclcpp/rclcpp.hpp"

namespace br2_vff_avoidance
{

struct VFFVectors
{
  std::vector<float> attractive;
  std::vector<float> repulsive;
  std::vector<float> result;
};

typedef enum {RED, GREEN, BLUE, NUM_COLORS} VFFColor;

class AvoidanceNode : public rclcpp::Node
{
public:
  AvoidanceNode();

  void scan_callback(sensor_msgs::msg::LaserScan::UniquePtr msg);
  void control_cycle();

protected:
  VFFVectors get_vff(const sensor_msgs::msg::LaserScan & scan);

  visualization_msgs::msg::MarkerArray get_debug_vff(const VFFVectors & vff_vectors);
  visualization_msgs::msg::Marker make_marker(
    const std::vector<float> & vector, VFFColor vff_color);

private:
  rclcpp::Publisher<geometry_msgs::msg::Twist>::SharedPtr vel_pub_;
  rclcpp::Publisher<visualization_msgs::msg::MarkerArray>::SharedPtr vff_debug_pub_;
  rclcpp::Subscription<sensor_msgs::msg::LaserScan>::SharedPtr scan_sub_;
  rclcpp::TimerBase::SharedPtr timer_;

  sensor_msgs::msg::LaserScan::UniquePtr last_scan_;
};

}  // namespace br2_vff_avoidance

#endif  // BR2_VFF_AVOIDANCE__AVOIDANCENODE_HPP_
    \end{minted}
    \end{tcolorbox}
  \normalsize

 \footnotesize
\begin{tcolorbox}[sharp corners, colframe=gray!80, colback=LightGray, left=0pt, top=0pt, bottom=0pt, title=\texttt{br2\_vff\_avoidance/src/br2\_vff\_avoidance/AvoidanceNode.cpp}]
  \begin{minted}[
    framesep=2mm,
    baselinestretch=0.8,
    bgcolor=LightGray,
    fontsize=\scriptsize
  ]{CPP}
// Copyright 2021 Intelligent Robotics Lab
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.


#include <memory>
#include <utility>
#include <algorithm>
#include <vector>

#include "geometry_msgs/msg/twist.hpp"
#include "sensor_msgs/msg/laser_scan.hpp"
#include "visualization_msgs/msg/marker_array.hpp"

#include "br2_vff_avoidance/AvoidanceNode.hpp"

#include "rclcpp/rclcpp.hpp"

using std::placeholders::_1;
using namespace std::chrono_literals;

namespace br2_vff_avoidance
{

AvoidanceNode::AvoidanceNode()
: Node("avoidance_vff")
{
  vel_pub_ = create_publisher<geometry_msgs::msg::Twist>("output_vel", 100);
  vff_debug_pub_ = create_publisher<visualization_msgs::msg::MarkerArray>("vff_debug", 100);

  scan_sub_ = create_subscription<sensor_msgs::msg::LaserScan>(
    "input_scan", rclcpp::SensorDataQoS(), std::bind(&AvoidanceNode::scan_callback, this, _1));

  timer_ = create_wall_timer(50ms, std::bind(&AvoidanceNode::control_cycle, this));
}

void
AvoidanceNode::scan_callback(sensor_msgs::msg::LaserScan::UniquePtr msg)
{
  last_scan_ = std::move(msg);
}

void
AvoidanceNode::control_cycle()
{
  // Skip cycle if no valid recent scan available
  if (last_scan_ == nullptr || (now() - last_scan_->header.stamp) > 1s) {
    return;
  }

  // Get VFF vectors
  const VFFVectors & vff = get_vff(*last_scan_);

  // Use result vector to calculate output speed
  const auto & v = vff.result;
  double angle = atan2(v[1], v[0]);
  double module = sqrt(v[0] * v[0] + v[1] * v[1]);

  // Create ouput message, controlling speed limits
  geometry_msgs::msg::Twist vel;
  vel.linear.x = std::clamp(module, 0.0, 0.3);  // truncate linear vel to [0.0, 0.3] m/s
  vel.angular.z = std::clamp(angle, -0.5, 0.5);  // truncate rotation vel to [-0.5, 0.5] rad/s

  vel_pub_->publish(vel);

  // Produce debug information, if any interested
  if (vff_debug_pub_->get_subscription_count() > 0) {
    vff_debug_pub_->publish(get_debug_vff(vff));
  }
}

VFFVectors
AvoidanceNode::get_vff(const sensor_msgs::msg::LaserScan & scan)
{
  // This is the obstacle radious in which an obstacle affects the robot
  const float OBSTACLE_DISTANCE = 1.0;

  // Init vectors
  VFFVectors vff_vector;
  vff_vector.attractive = {OBSTACLE_DISTANCE, 0.0};  // Robot wants to go forward
  vff_vector.repulsive = {0.0, 0.0};
  vff_vector.result = {0.0, 0.0};

  // Get the index of nearest obstacle
  int min_idx = std::min_element(scan.ranges.begin(), scan.ranges.end()) - scan.ranges.begin();

  // Get the distance to nearest obstacle
  float distance_min = scan.ranges[min_idx];

  // If the obstacle is in the area that affects the robot, calculate repulsive vector
  if (distance_min < OBSTACLE_DISTANCE) {
    float angle = scan.angle_min + scan.angle_increment * min_idx;

    float oposite_angle = angle + M_PI;
    // The module of the vector is inverse to the distance to the obstacle
    float complementary_dist = OBSTACLE_DISTANCE - distance_min;

    // Get cartesian (x, y) components from polar (angle, distance)
    vff_vector.repulsive[0] = cos(oposite_angle) * complementary_dist;
    vff_vector.repulsive[1] = sin(oposite_angle) * complementary_dist;
  }

  // Calculate resulting vector adding attractive and repulsive vectors
  vff_vector.result[0] = (vff_vector.repulsive[0] + vff_vector.attractive[0]);
  vff_vector.result[1] = (vff_vector.repulsive[1] + vff_vector.attractive[1]);

  return vff_vector;
}

visualization_msgs::msg::MarkerArray
AvoidanceNode::get_debug_vff(const VFFVectors & vff_vectors)
{
  visualization_msgs::msg::MarkerArray marker_array;

  marker_array.markers.push_back(make_marker(vff_vectors.attractive, BLUE));
  marker_array.markers.push_back(make_marker(vff_vectors.repulsive, RED));
  marker_array.markers.push_back(make_marker(vff_vectors.result, GREEN));

  return marker_array;
}

visualization_msgs::msg::Marker
AvoidanceNode::make_marker(const std::vector<float> & vector, VFFColor vff_color)
{
  visualization_msgs::msg::Marker marker;

  marker.header.frame_id = "base_footprint";
  marker.header.stamp = now();
  marker.type = visualization_msgs::msg::Marker::ARROW;
  marker.id = visualization_msgs::msg::Marker::ADD;

  geometry_msgs::msg::Point start;
  start.x = 0.0;
  start.y = 0.0;
  geometry_msgs::msg::Point end;
  start.x = vector[0];
  start.y = vector[1];
  marker.points = {end, start};

  marker.scale.x = 0.05;
  marker.scale.y = 0.1;

  switch (vff_color) {
    case RED:
      marker.id = 0;
      marker.color.r = 1.0;
      break;
    case GREEN:
      marker.id = 1;
      marker.color.g = 1.0;
      break;
    case BLUE:
      marker.id = 2;
      marker.color.b = 1.0;
      break;
  }
  marker.color.a = 1.0;

  return marker;
}


}  // namespace br2_vff_avoidance
    \end{minted}
    \end{tcolorbox}
  \normalsize

 \footnotesize
\begin{tcolorbox}[sharp corners, colframe=gray!80, colback=LightGray, left=0pt, top=0pt, bottom=0pt, title=\texttt{br2\_vff\_avoidance/src/avoidance\_vff\_main.cpp}]
  \begin{minted}[
    framesep=2mm,
    baselinestretch=0.8,
    bgcolor=LightGray,
    fontsize=\scriptsize
  ]{CPP}
// Copyright 2021 Intelligent Robotics Lab
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

#include <memory>

#include "br2_vff_avoidance/AvoidanceNode.hpp"
#include "rclcpp/rclcpp.hpp"

int main(int argc, char * argv[])
{
  rclcpp::init(argc, argv);

  auto avoidance_node = std::make_shared<br2_vff_avoidance::AvoidanceNode>();
  rclcpp::spin(avoidance_node);

  rclcpp::shutdown();

  return 0;
}
    \end{minted}
    \end{tcolorbox}
  \normalsize

 \footnotesize
\begin{tcolorbox}[sharp corners, colframe=gray!80, colback=LightGray, left=0pt, top=0pt, bottom=0pt, title=\texttt{br2\_vff\_avoidance/tests/vff\_test.cpp}]
  \begin{minted}[
    framesep=2mm,
    baselinestretch=0.8,
    bgcolor=LightGray,
    fontsize=\scriptsize
  ]{CPP}
// Copyright 2021 Intelligent Robotics Lab
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

#include <limits>
#include <vector>
#include <memory>

#include "sensor_msgs/msg/laser_scan.hpp"
#include "br2_vff_avoidance/AvoidanceNode.hpp"

#include "gtest/gtest.h"

using namespace std::chrono_literals;

class AvoidanceNodeTest : public br2_vff_avoidance::AvoidanceNode
{
public:
  br2_vff_avoidance::VFFVectors
  get_vff_test(const sensor_msgs::msg::LaserScan & scan)
  {
    return get_vff(scan);
  }

  visualization_msgs::msg::MarkerArray
  get_debug_vff_test(const br2_vff_avoidance::VFFVectors & vff_vectors)
  {
    return get_debug_vff(vff_vectors);
  }
};

sensor_msgs::msg::LaserScan get_scan_test_1(rclcpp::Time ts)
{
  sensor_msgs::msg::LaserScan ret;
  ret.header.stamp = ts;
  ret.angle_min = -M_PI;
  ret.angle_max = M_PI;
  ret.angle_increment = 2.0 * M_PI / 16.0;
  ret.ranges = std::vector<float>(16, std::numeric_limits<float>::infinity());

  return ret;
}

sensor_msgs::msg::LaserScan get_scan_test_2(rclcpp::Time ts)
{
  sensor_msgs::msg::LaserScan ret;
  ret.header.stamp = ts;
  ret.angle_min = -M_PI;
  ret.angle_max = M_PI;
  ret.angle_increment = 2.0 * M_PI / 16.0;
  ret.ranges = std::vector<float>(16, 0.0);

  return ret;
}

sensor_msgs::msg::LaserScan get_scan_test_3(rclcpp::Time ts)
{
  sensor_msgs::msg::LaserScan ret;
  ret.header.stamp = ts;
  ret.angle_min = -M_PI;
  ret.angle_max = M_PI;
  ret.angle_increment = 2.0 * M_PI / 16.0;
  ret.ranges = std::vector<float>(16, 5.0);
  ret.ranges[2] = 0.3;

  return ret;
}

sensor_msgs::msg::LaserScan get_scan_test_4(rclcpp::Time ts)
{
  sensor_msgs::msg::LaserScan ret;
  ret.header.stamp = ts;
  ret.angle_min = -M_PI;
  ret.angle_max = M_PI;
  ret.angle_increment = 2.0 * M_PI / 16.0;
  ret.ranges = std::vector<float>(16, 5.0);
  ret.ranges[6] = 0.3;

  return ret;
}

sensor_msgs::msg::LaserScan get_scan_test_5(rclcpp::Time ts)
{
  sensor_msgs::msg::LaserScan ret;
  ret.header.stamp = ts;
  ret.angle_min = -M_PI;
  ret.angle_max = M_PI;
  ret.angle_increment = 2.0 * M_PI / 16.0;
  ret.ranges = std::vector<float>(16, 5.0);
  ret.ranges[10] = 0.3;

  return ret;
}

sensor_msgs::msg::LaserScan get_scan_test_6(rclcpp::Time ts)
{
  sensor_msgs::msg::LaserScan ret;
  ret.header.stamp = ts;
  ret.angle_min = -M_PI;
  ret.angle_max = M_PI;
  ret.angle_increment = 2.0 * M_PI / 16.0;
  ret.ranges = std::vector<float>(16, 0.5);
  ret.ranges[10] = 0.3;

  return ret;
}

sensor_msgs::msg::LaserScan get_scan_test_7(rclcpp::Time ts)
{
  sensor_msgs::msg::LaserScan ret;
  ret.header.stamp = ts;
  ret.angle_min = -M_PI;
  ret.angle_max = M_PI;
  ret.angle_increment = 2.0 * M_PI / 16.0;
  ret.ranges = std::vector<float>(16, 5.0);
  ret.ranges[14] = 0.3;

  return ret;
}

sensor_msgs::msg::LaserScan get_scan_test_8(rclcpp::Time ts)
{
  sensor_msgs::msg::LaserScan ret;
  ret.header.stamp = ts;
  ret.angle_min = -M_PI;
  ret.angle_max = M_PI;
  ret.angle_increment = 2.0 * M_PI / 16.0;
  ret.ranges = std::vector<float>(16, 5.0);
  ret.ranges[8] = 0.01;

  return ret;
}

TEST(vff_tests, get_vff)
{
  auto node_avoidance = AvoidanceNodeTest();

  rclcpp::Time ts = node_avoidance.now();

  auto res1 = node_avoidance.get_vff_test(get_scan_test_1(ts));
  ASSERT_EQ(res1.attractive, std::vector<float>({1.0f, 0.0f}));
  ASSERT_EQ(res1.repulsive, std::vector<float>({0.0f, 0.0f}));
  ASSERT_EQ(res1.result, std::vector<float>({1.0f, 0.0f}));

  auto res2 = node_avoidance.get_vff_test(get_scan_test_2(ts));
  ASSERT_EQ(res2.attractive, std::vector<float>({1.0f, 0.0f}));
  ASSERT_NEAR(res2.repulsive[0], 1.0f, 0.00001f);
  ASSERT_NEAR(res2.repulsive[1], 0.0f, 0.00001f);
  ASSERT_NEAR(res2.result[0], 2.0f, 0.00001f);
  ASSERT_NEAR(res2.result[1], 0.0f, 0.00001f);

  auto res3 = node_avoidance.get_vff_test(get_scan_test_3(ts));
  ASSERT_EQ(res3.attractive, std::vector<float>({1.0f, 0.0f}));
  ASSERT_GT(res3.repulsive[0], 0.0f);
  ASSERT_GT(res3.repulsive[1], 0.0f);
  ASSERT_GT(atan2(res3.repulsive[1], res3.repulsive[0]), 0.1);
  ASSERT_LT(atan2(res3.repulsive[1], res3.repulsive[0]), M_PI_2);
  ASSERT_GT(atan2(res3.result[1], res3.result[0]), 0.1);
  ASSERT_LT(atan2(res3.result[1], res3.result[0]), M_PI_2);

  auto res4 = node_avoidance.get_vff_test(get_scan_test_4(ts));
  ASSERT_EQ(res4.attractive, std::vector<float>({1.0f, 0.0f}));
  ASSERT_LT(res4.repulsive[0], 0.0f);
  ASSERT_GT(res4.repulsive[1], 0.0f);
  ASSERT_GT(atan2(res4.repulsive[1], res4.repulsive[0]), M_PI_2);
  ASSERT_LT(atan2(res4.repulsive[1], res4.repulsive[0]), M_PI);
  ASSERT_GT(atan2(res4.result[1], res4.result[0]), 0.0);
  ASSERT_LT(atan2(res4.result[1], res4.result[0]), M_PI_2);

  auto res5 = node_avoidance.get_vff_test(get_scan_test_5(ts));
  ASSERT_EQ(res5.attractive, std::vector<float>({1.0f, 0.0f}));
  ASSERT_LT(res5.repulsive[0], 0.0f);
  ASSERT_LT(res5.repulsive[1], 0.0f);
  ASSERT_GT(atan2(res5.repulsive[1], res5.repulsive[0]), -M_PI);
  ASSERT_LT(atan2(res5.repulsive[1], res5.repulsive[0]), -M_PI_2);
  ASSERT_LT(atan2(res5.result[1], res5.result[0]), 0.0);
  ASSERT_GT(atan2(res5.result[1], res5.result[0]), -M_PI_2);

  auto res6 = node_avoidance.get_vff_test(get_scan_test_6(ts));
  ASSERT_EQ(res6.attractive, std::vector<float>({1.0f, 0.0f}));
  ASSERT_LT(res6.repulsive[0], 0.0f);
  ASSERT_LT(res6.repulsive[1], 0.0f);
  ASSERT_GT(atan2(res6.repulsive[1], res6.repulsive[0]), -M_PI);
  ASSERT_LT(atan2(res6.repulsive[1], res6.repulsive[0]), -M_PI_2);
  ASSERT_LT(atan2(res6.result[1], res6.result[0]), 0.0);
  ASSERT_GT(atan2(res6.result[1], res6.result[0]), -M_PI_2);

  auto res7 = node_avoidance.get_vff_test(get_scan_test_7(ts));
  ASSERT_EQ(res7.attractive, std::vector<float>({1.0f, 0.0f}));
  ASSERT_GT(res7.repulsive[0], 0.0f);
  ASSERT_LT(res7.repulsive[1], 0.0f);
  ASSERT_LT(atan2(res7.repulsive[1], res7.repulsive[0]), 0.0f);
  ASSERT_GT(atan2(res7.repulsive[1], res7.repulsive[0]), -M_PI_2);
  ASSERT_LT(atan2(res7.result[1], res7.result[0]), 0.0);
  ASSERT_GT(atan2(res7.result[1], res7.result[0]), -M_PI_2);

  auto res8 = node_avoidance.get_vff_test(get_scan_test_8(ts));
  ASSERT_EQ(res8.attractive, std::vector<float>({1.0f, 0.0f}));
  ASSERT_NEAR(res8.repulsive[0], -1.0f, 0.1f);
  ASSERT_NEAR(res8.repulsive[1], 0.0f, 0.0001f);
  ASSERT_NEAR(res8.result[0], 0.0f, 0.01f);
  ASSERT_NEAR(res8.result[1], 0.0f, 0.01f);
}

TEST(vff_tests, ouput_vels)
{
  auto node_avoidance = std::make_shared<AvoidanceNodeTest>();

  // Create a testing node with a scan publisher and a speed subscriber
  auto test_node = rclcpp::Node::make_shared("test_node");
  auto scan_pub = test_node->create_publisher<sensor_msgs::msg::LaserScan>("input_scan", 100);

  geometry_msgs::msg::Twist last_vel;
  auto vel_sub = test_node->create_subscription<geometry_msgs::msg::Twist>(
    "output_vel", 1, [&last_vel](geometry_msgs::msg::Twist::SharedPtr msg) {
      last_vel = *msg;
    });

  ASSERT_EQ(vel_sub->get_publisher_count(), 1);
  ASSERT_EQ(scan_pub->get_subscription_count(), 1);

  rclcpp::Rate rate(30);
  rclcpp::executors::SingleThreadedExecutor executor;
  executor.add_node(node_avoidance);
  executor.add_node(test_node);

  // Test for scan test #1
  auto start = node_avoidance->now();
  while (rclcpp::ok() && (node_avoidance->now() - start) < 1s) {
    scan_pub->publish(get_scan_test_1(node_avoidance->now()));
    executor.spin_some();
    rate.sleep();
  }
  ASSERT_NEAR(last_vel.linear.x, 0.3f, 0.0001f);
  ASSERT_NEAR(last_vel.angular.z, 0.0f, 0.0001f);

  // Test for scan test #2
  start = node_avoidance->now();
  while (rclcpp::ok() && (node_avoidance->now() - start) < 1s) {
    scan_pub->publish(get_scan_test_2(node_avoidance->now()));
    executor.spin_some();
    rate.sleep();
  }
  ASSERT_NEAR(last_vel.linear.x, 0.3f, 0.0001f);
  ASSERT_NEAR(last_vel.angular.z, 0.0f, 0.0001f);

  // Test for scan test #3
  start = node_avoidance->now();
  while (rclcpp::ok() && (node_avoidance->now() - start) < 1s) {
    scan_pub->publish(get_scan_test_3(node_avoidance->now()));
    executor.spin_some();
    rate.sleep();
  }
  ASSERT_LT(last_vel.linear.x, 0.3f);
  ASSERT_GT(last_vel.linear.x, 0.0f);
  ASSERT_GT(last_vel.angular.z, 0.0f);
  ASSERT_LT(last_vel.angular.z, M_PI_2);

  // Test for scan test #4
  start = node_avoidance->now();
  while (rclcpp::ok() && (node_avoidance->now() - start) < 1s) {
    scan_pub->publish(get_scan_test_4(node_avoidance->now()));
    executor.spin_some();
    rate.sleep();
  }
  ASSERT_LT(last_vel.linear.x, 0.3f);
  ASSERT_GT(last_vel.linear.x, 0.0f);
  ASSERT_GT(last_vel.angular.z, 0.0f);
  ASSERT_LT(last_vel.angular.z, M_PI_2);

  // Test for scan test #5
  start = node_avoidance->now();
  while (rclcpp::ok() && (node_avoidance->now() - start) < 1s) {
    scan_pub->publish(get_scan_test_5(node_avoidance->now()));
    executor.spin_some();
    rate.sleep();
  }
  ASSERT_LT(last_vel.linear.x, 0.3f);
  ASSERT_GT(last_vel.linear.x, 0.0f);
  ASSERT_LT(last_vel.angular.z, 0.0f);
  ASSERT_GT(last_vel.angular.z, -M_PI_2);

  // Test for scan test #6
  start = node_avoidance->now();
  while (rclcpp::ok() && (node_avoidance->now() - start) < 1s) {
    scan_pub->publish(get_scan_test_6(node_avoidance->now()));
    executor.spin_some();
    rate.sleep();
  }
  ASSERT_LT(last_vel.linear.x, 0.3f);
  ASSERT_GT(last_vel.linear.x, 0.0f);
  ASSERT_LT(last_vel.angular.z, 0.0f);
  ASSERT_GT(last_vel.angular.z, -M_PI_2);

  // Test for scan test #7
  start = node_avoidance->now();
  while (rclcpp::ok() && (node_avoidance->now() - start) < 1s) {
    scan_pub->publish(get_scan_test_7(node_avoidance->now()));
    executor.spin_some();
    rate.sleep();
  }
  ASSERT_LT(last_vel.linear.x, 0.3f);
  ASSERT_GT(last_vel.linear.x, 0.0f);
  ASSERT_LT(last_vel.angular.z, 0.0f);
  ASSERT_GT(last_vel.angular.z, -M_PI_2);

  // Test for scan test #8
  start = node_avoidance->now();
  while (rclcpp::ok() && (node_avoidance->now() - start) < 2s) {
    scan_pub->publish(get_scan_test_8(node_avoidance->now()));
    executor.spin_some();
    rate.sleep();
  }
  ASSERT_NEAR(last_vel.linear.x, 0.0f, 0.1f);
  ASSERT_LT(last_vel.angular.z, 0.0f);
  ASSERT_GT(last_vel.angular.z, -M_PI_2);

  // Test for stooping when scan is too old
  last_vel = geometry_msgs::msg::Twist();
  while (rclcpp::ok() && (node_avoidance->now() - start) < 3s) {
    scan_pub->publish(get_scan_test_6(start));
    executor.spin_some();
    rate.sleep();
  }
  ASSERT_NEAR(last_vel.linear.x, 0.0f, 0.01f);
  ASSERT_NEAR(last_vel.angular.z, 0.0f, 0.01f);
}

int main(int argc, char ** argv)
{
  rclcpp::init(argc, argv);

  testing::InitGoogleTest(&argc, argv);
  return RUN_ALL_TESTS();
}
    \end{minted}
    \end{tcolorbox}
  \normalsize

 \footnotesize
\begin{tcolorbox}[sharp corners, colframe=gray!80, colback=LightGray, left=0pt, top=0pt, bottom=0pt, title=\texttt{br2\_vff\_avoidance/tests/CMakeLists.txt}]
  \begin{minted}[
    framesep=2mm,
    baselinestretch=0.8,
    bgcolor=LightGray,
    fontsize=\scriptsize
  ]{CMake}

ament_add_gtest(vff_test vff_test.cpp)
ament_target_dependencies(vff_test ${dependencies})
target_link_libraries(vff_test ${PROJECT_NAME})
    \end{minted}
    \end{tcolorbox}
  \normalsize



\appendix

\chapter[Source Code]{Source Code}
\label{cap:source}
Complete list of source code used in the book, also available in:

\vspace{0.5cm}
\large
\texttt{https://github.com/fmrico/book\_ros2}
\normalsize
)
\section{Package \texttt{br2\_tracking\_msgs}}
\label{sec:anex:br2_tracking_msgs}

 \footnotesize
\begin{tcolorbox}[sharp corners, colframe=gray!80, colback=LightGray, left=0pt, top=0pt, bottom=0pt, title=Package \texttt{br2\_tracking\_msgs}]
  \begin{minted}[
    framesep=2mm,
    baselinestretch=0.8,
    bgcolor=LightGreen,
    fontsize=\scriptsize
  ]{console}
br2_tracking_msgs
├── CMakeLists.txt
├── msg
│   └── PanTiltCommand.msg
└── package.xml    \end{minted}
    \end{tcolorbox}
  \normalsize

 \footnotesize
\begin{tcolorbox}[sharp corners, colframe=gray!80, colback=LightGray, left=0pt, top=0pt, bottom=0pt, title=\texttt{br2\_tracking\_msgs/CMakeLists.txt}]
  \begin{minted}[
    framesep=2mm,
    baselinestretch=0.8,
    bgcolor=LightGray,
    fontsize=\scriptsize
  ]{CMake}
project(br2_tracking_msgs)

cmake_minimum_required(VERSION 3.5)

find_package(ament_cmake REQUIRED)
find_package(builtin_interfaces REQUIRED)
find_package(rosidl_default_generators REQUIRED)

rosidl_generate_interfaces(${PROJECT_NAME}
  "msg/PanTiltCommand.msg"
  DEPENDENCIES builtin_interfaces
)

ament_export_dependencies(rosidl_default_runtime)
ament_package()
    \end{minted}
    \end{tcolorbox}
  \normalsize

 \footnotesize
\begin{tcolorbox}[sharp corners, colframe=gray!80, colback=LightGray, left=0pt, top=0pt, bottom=0pt, title=\texttt{br2\_tracking\_msgs/package.xml}]
  \begin{minted}[
    framesep=2mm,
    baselinestretch=0.8,
    bgcolor=LightGray,
    fontsize=\scriptsize
  ]{XML}
<?xml version="1.0"?>
<?xml-model href="http://download.ros.org/schema/package_format3.xsd" schematypens="http://www.w3.org/2001/XMLSchema"?>
<package format="3">
  <name>br2_tracking_msgs</name>
  <version>0.0.0</version>

  <description>Messages for br2_tracking</description>

  <maintainer email="fmrico@gmail.com">Francisco Martin Rico</maintainer>

  <license>Apache License, Version 2.0</license>

  <buildtool_depend>ament_cmake</buildtool_depend>

  <depend>rclcpp</depend>
  <depend>builtin_interfaces</depend>
  <depend>rosidl_default_generators</depend>

  <member_of_group>rosidl_interface_packages</member_of_group>

  <export>
    <build_type>ament_cmake</build_type>
  </export>
</package>
    \end{minted}
    \end{tcolorbox}
  \normalsize



\appendix

\chapter[Source Code]{Source Code}
\label{cap:source}
Complete list of source code used in the book, also available in:

\vspace{0.5cm}
\large
\texttt{https://github.com/fmrico/book\_ros2}
\normalsize
)
\section{Package \texttt{br2\_tracking}}
\label{sec:anex:br2_tracking}

 \footnotesize
\begin{tcolorbox}[sharp corners, colframe=gray!80, colback=LightGray, left=0pt, top=0pt, bottom=0pt, title=Package \texttt{br2\_tracking}]
  \begin{minted}[
    framesep=2mm,
    baselinestretch=0.8,
    bgcolor=LightGreen,
    fontsize=\scriptsize
  ]{console}
br2_tracking
├── CMakeLists.txt
├── config
│   └── detector.yaml
├── include
│   └── br2_tracking
│       ├── HeadController.hpp
│       ├── ObjectDetector.hpp
│       └── PIDController.hpp
├── launch
│   └── tracking.launch.py
├── package.xml
├── src
│   ├── br2_tracking
│   │   ├── HeadController.cpp
│   │   ├── ObjectDetector.cpp
│   │   └── PIDController.cpp
│   ├── object_detector_main.cpp
│   └── object_tracker_main.cpp
└── tests
    ├── CMakeLists.txt
    └── pid_test.cpp    \end{minted}
    \end{tcolorbox}
  \normalsize

 \footnotesize
\begin{tcolorbox}[sharp corners, colframe=gray!80, colback=LightGray, left=0pt, top=0pt, bottom=0pt, title=\texttt{br2\_tracking/CMakeLists.txt}]
  \begin{minted}[
    framesep=2mm,
    baselinestretch=0.8,
    bgcolor=LightGray,
    fontsize=\scriptsize
  ]{CMake}
cmake_minimum_required(VERSION 3.5)
project(br2_tracking)

set(CMAKE_CXX_STANDARD 17)
set(CMAKE_BUILD_TYPE Debug)

find_package(ament_cmake REQUIRED)
find_package(rclcpp REQUIRED)
find_package(rclcpp_lifecycle REQUIRED)
find_package(br2_tracking_msgs REQUIRED)
find_package(sensor_msgs REQUIRED)
find_package(geometry_msgs REQUIRED)
find_package(vision_msgs REQUIRED)
find_package(control_msgs REQUIRED)
find_package(image_transport REQUIRED)
find_package(cv_bridge REQUIRED)

find_package(OpenCV REQUIRED)

set(dependencies
  rclcpp
  rclcpp_lifecycle
  br2_tracking_msgs
  sensor_msgs
  geometry_msgs
  vision_msgs
  control_msgs
  image_transport
  cv_bridge
  OpenCV
)

include_directories(include)

add_library(${PROJECT_NAME} SHARED
  src/br2_tracking/ObjectDetector.cpp
  src/br2_tracking/HeadController.cpp
  src/br2_tracking/PIDController.cpp
)
ament_target_dependencies(${PROJECT_NAME} ${dependencies})

add_executable(object_detector src/object_detector_main.cpp)
ament_target_dependencies(object_detector ${dependencies})
target_link_libraries(object_detector ${PROJECT_NAME})

add_executable(object_tracker src/object_tracker_main.cpp)
ament_target_dependencies(object_tracker ${dependencies})
target_link_libraries(object_tracker ${PROJECT_NAME})


install(TARGETS
  ${PROJECT_NAME}
  object_detector
  object_tracker
  ARCHIVE DESTINATION lib
  LIBRARY DESTINATION lib
  RUNTIME DESTINATION lib/${PROJECT_NAME}
)

install(
  DIRECTORY include
  DESTINATION include
)

install(DIRECTORY launch config DESTINATION share/${PROJECT_NAME})

if(BUILD_TESTING)
  find_package(ament_lint_auto REQUIRED)
  ament_lint_auto_find_test_dependencies()

  set(ament_cmake_cpplint_FOUND TRUE)
  ament_lint_auto_find_test_dependencies()

  find_package(ament_cmake_gtest REQUIRED)
  add_subdirectory(tests)
endif()

ament_export_include_directories(include)
ament_export_libraries(${PROJECT_NAME})
ament_export_dependencies(${dependencies})
ament_package()
    \end{minted}
    \end{tcolorbox}
  \normalsize

 \footnotesize
\begin{tcolorbox}[sharp corners, colframe=gray!80, colback=LightGray, left=0pt, top=0pt, bottom=0pt, title=\texttt{br2\_tracking/launch/tracking.launch.py}]
  \begin{minted}[
    framesep=2mm,
    baselinestretch=0.8,
    bgcolor=LightGray,
    fontsize=\scriptsize
  ]{Python}
# Copyright 2021 Intelligent Robotics Lab
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import os

from ament_index_python.packages import get_package_share_directory

from launch import LaunchDescription
from launch_ros.actions import Node


def generate_launch_description():

    params_file = os.path.join(
        get_package_share_directory('br2_tracking'),
        'config',
        'detector.yaml'
        )

    object_tracker_cmd = Node(
        package='br2_tracking',
        executable='object_tracker',
        parameters=[{
          'use_sim_time': True
        }, params_file],
        remappings=[
          ('input_image', '/head_front_camera/rgb/image_raw'),
          ('joint_state', '/head_controller/state'),
          ('joint_command', '/head_controller/joint_trajectory')
        ],
        output='screen'
    )

    ld = LaunchDescription()

    # Add any actions
    ld.add_action(object_tracker_cmd)

    return ld
    \end{minted}
    \end{tcolorbox}
  \normalsize

 \footnotesize
\begin{tcolorbox}[sharp corners, colframe=gray!80, colback=LightGray, left=0pt, top=0pt, bottom=0pt, title=\texttt{br2\_tracking/package.xml}]
  \begin{minted}[
    framesep=2mm,
    baselinestretch=0.8,
    bgcolor=LightGray,
    fontsize=\scriptsize
  ]{XML}
<?xml version="1.0"?>
<?xml-model href="http://download.ros.org/schema/package_format3.xsd" schematypens="http://www.w3.org/2001/XMLSchema"?>
<package format="3">
  <name>br2_tracking</name>
  <version>0.1.0</version>
  <description>Mastering Hierarchical Finite State Machines in ROS2 </description>
  <maintainer email="fmrico@gmail.com">fmrico</maintainer>
  <license>Apache 2.0</license>

  <buildtool_depend>ament_cmake</buildtool_depend>

  <depend>rclcpp</depend>
  <depend>rclcpp_lifecycle</depend>
  <depend>geometry_msgs</depend>
  <depend>br2_tracking_msgs</depend>
  <depend>sensor_msgs</depend>
  <depend>vision_msgs</depend>
  <depend>control_msgs</depend>
  <depend>image_transport</depend>
  <depend>cv_bridge</depend>

  <test_depend>ament_lint_auto</test_depend>
  <test_depend>ament_lint_common</test_depend>
  <test_depend>ament_cmake_gtest</test_depend>

  <export>
    <build_type>ament_cmake</build_type>
  </export>
</package>
    \end{minted}
    \end{tcolorbox}
  \normalsize

 \footnotesize
\begin{tcolorbox}[sharp corners, colframe=gray!80, colback=LightGray, left=0pt, top=0pt, bottom=0pt, title=\texttt{br2\_tracking/include/br2\_tracking/PIDController.hpp}]
  \begin{minted}[
    framesep=2mm,
    baselinestretch=0.8,
    bgcolor=LightGray,
    fontsize=\scriptsize
  ]{CPP}
// Copyright 2021 Intelligent Robotics Lab
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.


#ifndef BR2_TRACKING__PIDCONTROLLER_HPP_
#define BR2_TRACKING__PIDCONTROLLER_HPP_

#include <cmath>

namespace br2_tracking
{

class PIDController
{
public:
  PIDController(double min_ref, double max_ref, double min_output, double max_output);

  void set_pid(double n_KP, double n_KI, double n_KD);
  double get_output(double new_reference);

private:
  double KP_, KI_, KD_;

  double min_ref_, max_ref_;
  double min_output_, max_output_;
  double prev_error_, int_error_;
};

}  // namespace br2_tracking

#endif  // BR2_TRACKING__PIDCONTROLLER_HPP_
    \end{minted}
    \end{tcolorbox}
  \normalsize

 \footnotesize
\begin{tcolorbox}[sharp corners, colframe=gray!80, colback=LightGray, left=0pt, top=0pt, bottom=0pt, title=\texttt{br2\_tracking/include/br2\_tracking/ObjectDetector.hpp}]
  \begin{minted}[
    framesep=2mm,
    baselinestretch=0.8,
    bgcolor=LightGray,
    fontsize=\scriptsize
  ]{CPP}
// Copyright 2021 Intelligent Robotics Lab
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

#ifndef BR2_TRACKING__OBJECTDETECTOR_HPP_
#define BR2_TRACKING__OBJECTDETECTOR_HPP_

#include <memory>
#include <vector>

#include "vision_msgs/msg/detection2_d.hpp"

#include "image_transport/image_transport.hpp"
#include "rclcpp/rclcpp.hpp"

namespace br2_tracking
{

class ObjectDetector : public rclcpp::Node
{
public:
  ObjectDetector();

  void image_callback(const sensor_msgs::msg::Image::ConstSharedPtr & msg);

private:
  image_transport::Subscriber image_sub_;
  rclcpp::Publisher<vision_msgs::msg::Detection2D>::SharedPtr detection_pub_;

  // HSV ranges for detection [h - H] [s - S] [v - V]
  std::vector<double> hsv_filter_ranges_ {0, 180, 0, 255, 0, 255};
  bool debug_ {true};
};

}  // namespace br2_tracking

#endif  // BR2_TRACKING__OBJECTDETECTOR_HPP_
    \end{minted}
    \end{tcolorbox}
  \normalsize

 \footnotesize
\begin{tcolorbox}[sharp corners, colframe=gray!80, colback=LightGray, left=0pt, top=0pt, bottom=0pt, title=\texttt{br2\_tracking/include/br2\_tracking/HeadController.hpp}]
  \begin{minted}[
    framesep=2mm,
    baselinestretch=0.8,
    bgcolor=LightGray,
    fontsize=\scriptsize
  ]{CPP}
// Copyright 2021 Intelligent Robotics Lab
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

#ifndef BR2_TRACKING__HEADCONTROLLER_HPP_
#define BR2_TRACKING__HEADCONTROLLER_HPP_

#include <memory>

#include "br2_tracking_msgs/msg/pan_tilt_command.hpp"
#include "control_msgs/msg/joint_trajectory_controller_state.hpp"
#include "trajectory_msgs/msg/joint_trajectory.hpp"

#include "br2_tracking/PIDController.hpp"

#include "image_transport/image_transport.hpp"

#include "rclcpp_lifecycle/lifecycle_node.hpp"
#include "rclcpp/rclcpp.hpp"

namespace br2_tracking
{

using CallbackReturn = rclcpp_lifecycle::node_interfaces::LifecycleNodeInterface::CallbackReturn;

class HeadController : public rclcpp_lifecycle::LifecycleNode
{
public:
  HeadController();

  CallbackReturn on_configure(const rclcpp_lifecycle::State & previous_state);
  CallbackReturn on_activate(const rclcpp_lifecycle::State & previous_state);
  CallbackReturn on_deactivate(const rclcpp_lifecycle::State & previous_state);

  void control_sycle();

  void joint_state_callback(control_msgs::msg::JointTrajectoryControllerState::UniquePtr msg);
  void command_callback(br2_tracking_msgs::msg::PanTiltCommand::UniquePtr msg);

private:
  rclcpp::Subscription<br2_tracking_msgs::msg::PanTiltCommand>::SharedPtr command_sub_;
  rclcpp::Subscription<control_msgs::msg::JointTrajectoryControllerState>::SharedPtr joint_sub_;
  rclcpp_lifecycle::LifecyclePublisher<trajectory_msgs::msg::JointTrajectory>::SharedPtr
    joint_pub_;
  rclcpp::TimerBase::SharedPtr timer_;

  control_msgs::msg::JointTrajectoryControllerState::UniquePtr last_state_;
  br2_tracking_msgs::msg::PanTiltCommand::UniquePtr last_command_;
  rclcpp::Time last_command_ts_;

  PIDController pan_pid_, tilt_pid_;
};

}  // namespace br2_tracking

#endif  // BR2_TRACKING__HEADCONTROLLER_HPP_
    \end{minted}
    \end{tcolorbox}
  \normalsize

 \footnotesize
\begin{tcolorbox}[sharp corners, colframe=gray!80, colback=LightGray, left=0pt, top=0pt, bottom=0pt, title=\texttt{br2\_tracking/config/detector.yaml}]
  \begin{minted}[
    framesep=2mm,
    baselinestretch=0.8,
    bgcolor=LightGray,
    fontsize=\scriptsize
  ]{Yaml}
/object_detector:
  ros__parameters:
    debug: true
    hsv_ranges:
      - 15.0
      - 20.0
      - 50.0
      - 200.0
      - 20.0
      - 200.0
    \end{minted}
    \end{tcolorbox}
  \normalsize

 \footnotesize
\begin{tcolorbox}[sharp corners, colframe=gray!80, colback=LightGray, left=0pt, top=0pt, bottom=0pt, title=\texttt{br2\_tracking/src/br2\_tracking/PIDController.cpp}]
  \begin{minted}[
    framesep=2mm,
    baselinestretch=0.8,
    bgcolor=LightGray,
    fontsize=\scriptsize
  ]{CPP}
// Copyright 2021 Intelligent Robotics Lab
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

#include <algorithm>

#include "br2_tracking/PIDController.hpp"

namespace br2_tracking
{

PIDController::PIDController(double min_ref, double max_ref, double min_output, double max_output)
{
  min_ref_ = min_ref;
  max_ref_ = max_ref;
  min_output_ = min_output;
  max_output_ = max_output;
  prev_error_ = int_error_ = 0.0;

  KP_ = 0.41;
  KI_ = 0.06;
  KD_ = 0.53;
}

void
PIDController::set_pid(double n_KP, double n_KI, double n_KD)
{
  KP_ = n_KP;
  KI_ = n_KI;
  KD_ = n_KD;
}

double
PIDController::get_output(double new_reference)
{
  double ref = new_reference;
  double output = 0.0;

  // Proportional Error
  double direction = 0.0;
  if (ref != 0.0) {
    direction = ref / fabs(ref);
  }

  if (fabs(ref) < min_ref_) {
    output = 0.0;
  } else if (fabs(ref) > max_ref_) {
    output = direction * max_output_;
  } else {
    output = direction * min_output_ + ref * (max_output_ - min_output_);
  }

  // Integral Error
  int_error_ = (int_error_ + output) * 2.0 / 3.0;

  // Derivative Error
  double deriv_error = output - prev_error_;
  prev_error_ = output;

  output = KP_ * output + KI_ * int_error_ + KD_ * deriv_error;

  return std::clamp(output, -max_output_, max_output_);
}

}  // namespace br2_tracking
    \end{minted}
    \end{tcolorbox}
  \normalsize

 \footnotesize
\begin{tcolorbox}[sharp corners, colframe=gray!80, colback=LightGray, left=0pt, top=0pt, bottom=0pt, title=\texttt{br2\_tracking/src/br2\_tracking/HeadController.cpp}]
  \begin{minted}[
    framesep=2mm,
    baselinestretch=0.8,
    bgcolor=LightGray,
    fontsize=\scriptsize
  ]{CPP}
// Copyright 2021 Intelligent Robotics Lab
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

#include <algorithm>
#include <utility>

#include "br2_tracking/HeadController.hpp"
#include "br2_tracking/PIDController.hpp"

#include "br2_tracking_msgs/msg/pan_tilt_command.hpp"
#include "control_msgs/msg/joint_trajectory_controller_state.hpp"
#include "trajectory_msgs/msg/joint_trajectory.hpp"

#include "rclcpp_lifecycle/lifecycle_node.hpp"
#include "rclcpp/rclcpp.hpp"

namespace br2_tracking
{

using std::placeholders::_1;
using namespace std::chrono_literals;
using CallbackReturn = rclcpp_lifecycle::node_interfaces::LifecycleNodeInterface::CallbackReturn;

HeadController::HeadController()
: LifecycleNode("head_tracker"),
  pan_pid_(0.0, 1.0, 0.0, 0.3),
  tilt_pid_(0.0, 1.0, 0.0, 0.3)
{
  command_sub_ = create_subscription<br2_tracking_msgs::msg::PanTiltCommand>(
    "command", 100,
    std::bind(&HeadController::command_callback, this, _1));
  joint_sub_ = create_subscription<control_msgs::msg::JointTrajectoryControllerState>(
    "joint_state", rclcpp::SensorDataQoS(),
    std::bind(&HeadController::joint_state_callback, this, _1));
  joint_pub_ = create_publisher<trajectory_msgs::msg::JointTrajectory>("joint_command", 100);
}

CallbackReturn
HeadController::on_configure(const rclcpp_lifecycle::State & previous_state)
{
  RCLCPP_INFO(get_logger(), "HeadController configured");

  pan_pid_.set_pid(0.4, 0.05, 0.55);
  tilt_pid_.set_pid(0.4, 0.05, 0.55);

  return CallbackReturn::SUCCESS;
}

CallbackReturn
HeadController::on_activate(const rclcpp_lifecycle::State & previous_state)
{
  RCLCPP_INFO(get_logger(), "HeadController activated");

  joint_pub_->on_activate();
  timer_ = create_wall_timer(100ms, std::bind(&HeadController::control_sycle, this));

  return CallbackReturn::SUCCESS;
}

CallbackReturn
HeadController::on_deactivate(const rclcpp_lifecycle::State & previous_state)
{
  RCLCPP_INFO(get_logger(), "HeadController deactivated");

  trajectory_msgs::msg::JointTrajectory command_msg;
  command_msg.header.stamp = now();
  command_msg.joint_names = last_state_->joint_names;
  command_msg.points.resize(1);
  command_msg.points[0].positions.resize(2);
  command_msg.points[0].velocities.resize(2);
  command_msg.points[0].accelerations.resize(2);
  command_msg.points[0].positions[0] = 0.0;
  command_msg.points[0].positions[1] = 0.0;
  command_msg.points[0].velocities[0] = 0.1;
  command_msg.points[0].velocities[1] = 0.1;
  command_msg.points[0].accelerations[0] = 0.1;
  command_msg.points[0].accelerations[1] = 0.1;
  command_msg.points[0].time_from_start = rclcpp::Duration(1s);

  joint_pub_->publish(command_msg);

  joint_pub_->on_deactivate();
  timer_ = nullptr;

  return CallbackReturn::SUCCESS;
}

void
HeadController::joint_state_callback(
  control_msgs::msg::JointTrajectoryControllerState::UniquePtr msg)
{
  last_state_ = std::move(msg);
}

void
HeadController::command_callback(br2_tracking_msgs::msg::PanTiltCommand::UniquePtr msg)
{
  last_command_ = std::move(msg);
  last_command_ts_ = now();
}

void
HeadController::control_sycle()
{
  if (last_state_ == nullptr) {return;}

  trajectory_msgs::msg::JointTrajectory command_msg;
  command_msg.header.stamp = now();
  command_msg.joint_names = last_state_->joint_names;
  command_msg.points.resize(1);
  command_msg.points[0].positions.resize(2);
  command_msg.points[0].velocities.resize(2);
  command_msg.points[0].accelerations.resize(2);
  command_msg.points[0].time_from_start = rclcpp::Duration(200ms);

  if (last_command_ == nullptr || (now() - last_command_ts_) > 100ms) {
    command_msg.points[0].positions[0] = 0.0;
    command_msg.points[0].positions[1] = 0.0;
    command_msg.points[0].velocities[0] = 0.1;
    command_msg.points[0].velocities[1] = 0.1;
    command_msg.points[0].accelerations[0] = 0.1;
    command_msg.points[0].accelerations[1] = 0.1;
    command_msg.points[0].time_from_start = rclcpp::Duration(1s);
  } else {
    double control_pan = pan_pid_.get_output(last_command_->pan);
    double control_tilt = tilt_pid_.get_output(last_command_->tilt);

    command_msg.points[0].positions[0] = last_state_->actual.positions[0] - control_pan;
    command_msg.points[0].positions[1] = last_state_->actual.positions[1] - control_tilt;

    command_msg.points[0].velocities[0] = 0.5;
    command_msg.points[0].velocities[1] = 0.5;
    command_msg.points[0].accelerations[0] = 0.5;
    command_msg.points[0].accelerations[1] = 0.5;
  }

  joint_pub_->publish(command_msg);
}

}  // namespace br2_tracking
    \end{minted}
    \end{tcolorbox}
  \normalsize

 \footnotesize
\begin{tcolorbox}[sharp corners, colframe=gray!80, colback=LightGray, left=0pt, top=0pt, bottom=0pt, title=\texttt{br2\_tracking/src/br2\_tracking/ObjectDetector.cpp}]
  \begin{minted}[
    framesep=2mm,
    baselinestretch=0.8,
    bgcolor=LightGray,
    fontsize=\scriptsize
  ]{CPP}
// Copyright 2021 Intelligent Robotics Lab
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

#include <vector>

#include "opencv2/opencv.hpp"
#include "cv_bridge/cv_bridge.h"

#include "br2_tracking/ObjectDetector.hpp"

#include "geometry_msgs/msg/pose2_d.hpp"

#include "image_transport/image_transport.hpp"
#include "rclcpp/rclcpp.hpp"

namespace br2_tracking
{

using std::placeholders::_1;

ObjectDetector::ObjectDetector()
: Node("object_detector")
{
  image_sub_ = image_transport::create_subscription(
    this, "input_image", std::bind(&ObjectDetector::image_callback, this, _1),
    "raw", rclcpp::SensorDataQoS().get_rmw_qos_profile());

  detection_pub_ = create_publisher<vision_msgs::msg::Detection2D>("detection", 100);

  declare_parameter("hsv_ranges", hsv_filter_ranges_);
  declare_parameter("debug", debug_);

  get_parameter("hsv_ranges", hsv_filter_ranges_);
  get_parameter("debug", debug_);
}

void
ObjectDetector::image_callback(const sensor_msgs::msg::Image::ConstSharedPtr & msg)
{
  if (detection_pub_->get_subscription_count() == 0) {return;}

  const float & h = hsv_filter_ranges_[0];
  const float & H = hsv_filter_ranges_[1];
  const float & s = hsv_filter_ranges_[2];
  const float & S = hsv_filter_ranges_[3];
  const float & v = hsv_filter_ranges_[4];
  const float & V = hsv_filter_ranges_[5];

  cv_bridge::CvImagePtr cv_ptr;
  try {
    cv_ptr = cv_bridge::toCvCopy(msg, sensor_msgs::image_encodings::BGR8);
  } catch (cv_bridge::Exception & e) {
    RCLCPP_ERROR(get_logger(), "cv_bridge exception: %s", e.what());
    return;
  }

  cv::Mat img_hsv;
  cv::cvtColor(cv_ptr->image, img_hsv, cv::COLOR_BGR2HSV);

  cv::Mat1b filtered;
  cv::inRange(img_hsv, cv::Scalar(h, s, v), cv::Scalar(H, S, V), filtered);

  auto moment = cv::moments(filtered, true);
  cv::Rect bbx = cv::boundingRect(filtered);

  auto m = cv::moments(filtered, true);
  if (m.m00 < 0.000001) {return;}
  int cx = m.m10 / m.m00;
  int cy = m.m01 / m.m00;

  vision_msgs::msg::Detection2D detection_msg;
  detection_msg.header = msg->header;
  detection_msg.bbox.size_x = bbx.width;
  detection_msg.bbox.size_y = bbx.height;
  detection_msg.bbox.center.x = cx;
  detection_msg.bbox.center.y = cy;
  detection_msg.source_img = *cv_ptr->toImageMsg();
  detection_pub_->publish(detection_msg);

  if (debug_) {
    cv::rectangle(cv_ptr->image, bbx, cv::Scalar(0, 0, 255), 3);
    cv::circle(cv_ptr->image, cv::Point(cx, cy), 3, cv::Scalar(255, 0, 0), 3);
    cv::imshow("cv_ptr->image", cv_ptr->image);
    cv::waitKey(1);
  }
}

}  // namespace br2_tracking
    \end{minted}
    \end{tcolorbox}
  \normalsize

 \footnotesize
\begin{tcolorbox}[sharp corners, colframe=gray!80, colback=LightGray, left=0pt, top=0pt, bottom=0pt, title=\texttt{br2\_tracking/src/object\_tracker\_main.cpp}]
  \begin{minted}[
    framesep=2mm,
    baselinestretch=0.8,
    bgcolor=LightGray,
    fontsize=\scriptsize
  ]{CPP}
// Copyright 2021 Intelligent Robotics Lab
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

#include <memory>

#include "br2_tracking/ObjectDetector.hpp"
#include "br2_tracking/HeadController.hpp"

#include "br2_tracking_msgs/msg/pan_tilt_command.hpp"

#include "lifecycle_msgs/msg/transition.hpp"
#include "rclcpp/rclcpp.hpp"

int main(int argc, char * argv[])
{
  rclcpp::init(argc, argv);

  auto node_detector = std::make_shared<br2_tracking::ObjectDetector>();
  auto node_head_controller = std::make_shared<br2_tracking::HeadController>();
  auto node_tracker = rclcpp::Node::make_shared("tracker");

  auto command_pub = node_tracker->create_publisher<br2_tracking_msgs::msg::PanTiltCommand>(
    "/command", 100);
  auto detection_sub = node_tracker->create_subscription<vision_msgs::msg::Detection2D>(
    "/detection", rclcpp::SensorDataQoS(),
    [command_pub](vision_msgs::msg::Detection2D::SharedPtr msg) {
      br2_tracking_msgs::msg::PanTiltCommand command;
      command.pan = (msg->bbox.center.x / msg->source_img.width) * 2.0 - 1.0;
      command.tilt = (msg->bbox.center.y / msg->source_img.height) * 2.0 - 1.0;
      command_pub->publish(command);
    });

  rclcpp::executors::SingleThreadedExecutor executor;
  executor.add_node(node_detector);
  executor.add_node(node_head_controller->get_node_base_interface());
  executor.add_node(node_tracker);

  node_head_controller->trigger_transition(lifecycle_msgs::msg::Transition::TRANSITION_CONFIGURE);

  executor.spin();

  rclcpp::shutdown();
  return 0;
}
    \end{minted}
    \end{tcolorbox}
  \normalsize

 \footnotesize
\begin{tcolorbox}[sharp corners, colframe=gray!80, colback=LightGray, left=0pt, top=0pt, bottom=0pt, title=\texttt{br2\_tracking/src/object\_detector\_main.cpp}]
  \begin{minted}[
    framesep=2mm,
    baselinestretch=0.8,
    bgcolor=LightGray,
    fontsize=\scriptsize
  ]{CPP}
// Copyright 2021 Intelligent Robotics Lab
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

#include <memory>

#include "br2_tracking/ObjectDetector.hpp"
#include "rclcpp/rclcpp.hpp"

int main(int argc, char * argv[])
{
  rclcpp::init(argc, argv);

  auto node_detector = std::make_shared<br2_tracking::ObjectDetector>();

  rclcpp::spin(node_detector);

  rclcpp::shutdown();
  return 0;
}
    \end{minted}
    \end{tcolorbox}
  \normalsize

 \footnotesize
\begin{tcolorbox}[sharp corners, colframe=gray!80, colback=LightGray, left=0pt, top=0pt, bottom=0pt, title=\texttt{br2\_tracking/tests/CMakeLists.txt}]
  \begin{minted}[
    framesep=2mm,
    baselinestretch=0.8,
    bgcolor=LightGray,
    fontsize=\scriptsize
  ]{CMake}

ament_add_gtest(pid_test pid_test.cpp)
ament_target_dependencies(pid_test ${dependencies})
target_link_libraries(pid_test ${PROJECT_NAME})
    \end{minted}
    \end{tcolorbox}
  \normalsize

 \footnotesize
\begin{tcolorbox}[sharp corners, colframe=gray!80, colback=LightGray, left=0pt, top=0pt, bottom=0pt, title=\texttt{br2\_tracking/tests/pid\_test.cpp}]
  \begin{minted}[
    framesep=2mm,
    baselinestretch=0.8,
    bgcolor=LightGray,
    fontsize=\scriptsize
  ]{CPP}
// Copyright 2021 Intelligent Robotics Lab
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

#include <random>

#include "br2_tracking/PIDController.hpp"

#include "gtest/gtest.h"

TEST(pid_tests, pid_test_1)
{
  br2_tracking::PIDController pid(0.0, 1.0, 0.0, 1.0);

  ASSERT_NEAR(pid.get_output(0.0), 0.0, 0.05);
  ASSERT_LT(pid.get_output(0.1), 0.099);
  ASSERT_GT(pid.get_output(0.1), -0.4);
  ASSERT_LT(pid.get_output(0.1), 0.3);
}

TEST(pid_tests, pid_test_2)
{
  br2_tracking::PIDController pid(0.0, 1.0, 0.0, 1.0);
  pid.set_pid(1.0, 0.0, 0.0);

  std::random_device rd;
  std::mt19937 gen(rd());
  std::uniform_real_distribution<> dis(-5.0, 5.0);

  for (int n = 0; n < 100000; n++) {
    double random_number = dis(gen);
    double output = pid.get_output(random_number);

    ASSERT_LE(output, 1.0);
    ASSERT_GE(output, -1.0);

    if (output < -2.0) {
      ASSERT_NEAR(output, -1.0, 0.01);
    }
    if (output > 2.0) {
      ASSERT_NEAR(output, 1.0, 0.01);
    }
    if (output > 0.0) {
      ASSERT_GT(output, 0.0);
    }
    if (output < 0.0) {
      ASSERT_LT(output, 0.0);
    }
  }
}

int main(int argc, char ** argv)
{
  testing::InitGoogleTest(&argc, argv);
  return RUN_ALL_TESTS();
}
    \end{minted}
    \end{tcolorbox}
  \normalsize



\appendix

\chapter[Source Code]{Source Code}
\label{cap:source}
Complete list of source code used in the book, also available in:

\vspace{0.5cm}
\large
\texttt{https://github.com/fmrico/book\_ros2}
\normalsize
)
\section{Package \texttt{br2\_bt\_bumpgo}}
\label{sec:anex:br2_bt_bumpgo}

 \footnotesize
\begin{tcolorbox}[sharp corners, colframe=gray!80, colback=LightGray, left=0pt, top=0pt, bottom=0pt, title=Package \texttt{br2\_bt\_bumpgo}]
  \begin{minted}[
    framesep=2mm,
    baselinestretch=0.8,
    bgcolor=LightGreen,
    fontsize=\scriptsize
  ]{console}
br2_bt_bumpgo
├── behavior_tree_xml
│   └── bumpgo.xml
├── cmake
│   └── FindZMQ.cmake
├── CMakeLists.txt
├── include
│   └── br2_bt_bumpgo
│       ├── Back.hpp
│       ├── Forward.hpp
│       ├── IsObstacle.hpp
│       └── Turn.hpp
├── package.xml
├── src
│   ├── br2_bt_bumpgo
│   │   ├── Back.cpp
│   │   ├── Forward.cpp
│   │   ├── IsObstacle.cpp
│   │   └── Turn.cpp
│   └── bt_bumpgo_main.cpp
└── tests
    ├── bt_action_test.cpp
    ├── bt_forward_main.cpp
    └── CMakeLists.txt    \end{minted}
    \end{tcolorbox}
  \normalsize

 \footnotesize
\begin{tcolorbox}[sharp corners, colframe=gray!80, colback=LightGray, left=0pt, top=0pt, bottom=0pt, title=\texttt{br2\_bt\_bumpgo/behavior\_tree\_xml/bumpgo.xml}]
  \begin{minted}[
    framesep=2mm,
    baselinestretch=0.8,
    bgcolor=LightGray,
    fontsize=\scriptsize
  ]{XML}
<?xml version="1.0"?>
<root main_tree_to_execute="BehaviorTree">
    <!-- ////////// -->
    <BehaviorTree ID="BehaviorTree">
        <ReactiveSequence>
            <Fallback>
                <Inverter>
                    <Condition ID="IsObstacle" distance="1.0"/>
                </Inverter>
                <Sequence>
                    <Action ID="Back"/>
                    <Action ID="Turn"/>
                </Sequence>
            </Fallback>
            <Action ID="Forward"/>
        </ReactiveSequence>
    </BehaviorTree>
    <!-- ////////// -->
    <TreeNodesModel>
        <Action ID="Back"/>
        <Action ID="Forward"/>
        <Condition ID="IsObstacle">
            <input_port default="1.0" name="distance">Distance to consider obstacle</input_port>
        </Condition>
        <Action ID="Turn"/>
    </TreeNodesModel>
    <!-- ////////// -->
</root>

    \end{minted}
    \end{tcolorbox}
  \normalsize

 \footnotesize
\begin{tcolorbox}[sharp corners, colframe=gray!80, colback=LightGray, left=0pt, top=0pt, bottom=0pt, title=\texttt{br2\_bt\_bumpgo/CMakeLists.txt}]
  \begin{minted}[
    framesep=2mm,
    baselinestretch=0.8,
    bgcolor=LightGray,
    fontsize=\scriptsize
  ]{CMake}
cmake_minimum_required(VERSION 3.5)
project(br2_bt_bumpgo)

set(CMAKE_CONFIG_PATH ${CMAKE_MODULE_PATH}  "${CMAKE_CURRENT_LIST_DIR}/cmake")
list(APPEND CMAKE_MODULE_PATH "${CMAKE_CONFIG_PATH}")

find_package(ament_cmake REQUIRED)
find_package(rclcpp REQUIRED)
find_package(behaviortree_cpp_v3 REQUIRED)
find_package(sensor_msgs REQUIRED)
find_package(geometry_msgs REQUIRED)
find_package(ament_index_cpp REQUIRED)

find_package(ZMQ)
if(ZMQ_FOUND)
    message(STATUS "ZeroMQ found.")
    add_definitions(-DZMQ_FOUND)
else()
  message(WARNING "ZeroMQ NOT found. Not including PublisherZMQ.")
endif()

set(CMAKE_CXX_STANDARD 17)

set(dependencies
    rclcpp
    behaviortree_cpp_v3
    sensor_msgs
    geometry_msgs
    ament_index_cpp
)

include_directories(include ${ZMQ_INCLUDE_DIRS})

add_library(br2_forward_bt_node SHARED src/br2_bt_bumpgo/Forward.cpp)
add_library(br2_back_bt_node SHARED src/br2_bt_bumpgo/Back.cpp)
add_library(br2_turn_bt_node SHARED src/br2_bt_bumpgo/Turn.cpp)
add_library(br2_is_obstacle_bt_node SHARED src/br2_bt_bumpgo/IsObstacle.cpp)

list(APPEND plugin_libs
  br2_forward_bt_node
  br2_back_bt_node
  br2_turn_bt_node
  br2_is_obstacle_bt_node
)

foreach(bt_plugin ${plugin_libs})
  ament_target_dependencies(${bt_plugin} ${dependencies})
  target_compile_definitions(${bt_plugin} PRIVATE BT_PLUGIN_EXPORT)
endforeach()

add_executable(bt_bumpgo src/bt_bumpgo_main.cpp)
ament_target_dependencies(bt_bumpgo ${dependencies})
target_link_libraries(bt_bumpgo ${ZMQ_LIBRARIES})

install(TARGETS
  ${plugin_libs}
  bt_bumpgo
  ARCHIVE DESTINATION lib
  LIBRARY DESTINATION lib
  RUNTIME DESTINATION lib/${PROJECT_NAME}
)

install(DIRECTORY include/
  DESTINATION include/
)

install(DIRECTORY behavior_tree_xml
  DESTINATION share/${PROJECT_NAME}
)


if(BUILD_TESTING)
  find_package(ament_lint_auto REQUIRED)
  ament_lint_auto_find_test_dependencies()

  set(ament_cmake_cpplint_FOUND TRUE)
  ament_lint_auto_find_test_dependencies()

  find_package(ament_cmake_gtest REQUIRED)

  add_subdirectory(tests)
endif()

ament_export_include_directories(include)
ament_export_dependencies(${dependencies})

ament_package()
    \end{minted}
    \end{tcolorbox}
  \normalsize

 \footnotesize
\begin{tcolorbox}[sharp corners, colframe=gray!80, colback=LightGray, left=0pt, top=0pt, bottom=0pt, title=\texttt{br2\_bt\_bumpgo/cmake/FindZMQ.cmake}]
  \begin{minted}[
    framesep=2mm,
    baselinestretch=0.8,
    bgcolor=LightGray,
    fontsize=\scriptsize
  ]{CMake}
# - Try to find ZMQ
# Once done this will define
#
#  ZMQ_FOUND - system has ZMQ
#  ZMQ_INCLUDE_DIRS - the ZMQ include directory
#  ZMQ_LIBRARIES - Link these to use ZMQ
#  ZMQ_DEFINITIONS - Compiler switches required for using ZMQ
#
#  Copyright (c) 2011 Lee Hambley <lee.hambley@gmail.com>
#
#  All rights reserved.
#
#  Software License Agreement (BSD License 2.0)
#
#  Redistribution and use in source and binary forms, with or without
#  modification, are permitted provided that the following conditions
#  are met:
#
#   * Redistributions of source code must retain the above copyright
#     notice, this list of conditions and the following disclaimer.
#   * Redistributions in binary form must reproduce the above
#     copyright notice, this list of conditions and the following
#     disclaimer in the documentation and/or other materials provided
#     with the distribution.
#   * Neither the name of {copyright_holder} nor the names of its
#     contributors may be used to endorse or promote products derived
#     from this software without specific prior written permission.
#
#  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
#  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
#  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
#  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
#  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
#  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
#  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
#  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
#  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
#  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
#  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
#  POSSIBILITY OF SUCH DAMAGE.


if(ZMQ_LIBRARIES AND ZMQ_INCLUDE_DIRS)
  # in cache already
  set(ZMQ_FOUND TRUE)
else()

  find_path(ZMQ_INCLUDE_DIR
    NAMES
      zmq.h
    PATHS
      /usr/include
      /usr/local/include
      /opt/local/include
      /sw/include
  )

  find_library(ZMQ_LIBRARY
    NAMES
      zmq
    PATHS
      /usr/lib
      /usr/local/lib
      /opt/local/lib
      /sw/lib
  )

  set(ZMQ_INCLUDE_DIRS
    ${ZMQ_INCLUDE_DIR}
  )

  if(ZMQ_LIBRARY)
    set(ZMQ_LIBRARIES
        ${ZMQ_LIBRARIES}
        ${ZMQ_LIBRARY}
    )
  endif()

  include(FindPackageHandleStandardArgs)
  find_package_handle_standard_args(ZMQ DEFAULT_MSG ZMQ_LIBRARIES ZMQ_INCLUDE_DIRS)

  # show the ZMQ_INCLUDE_DIRS and ZMQ_LIBRARIES variables only in the advanced view
  mark_as_advanced(ZMQ_INCLUDE_DIRS ZMQ_LIBRARIES)

endif()

    \end{minted}
    \end{tcolorbox}
  \normalsize

 \footnotesize
\begin{tcolorbox}[sharp corners, colframe=gray!80, colback=LightGray, left=0pt, top=0pt, bottom=0pt, title=\texttt{br2\_bt\_bumpgo/package.xml}]
  \begin{minted}[
    framesep=2mm,
    baselinestretch=0.8,
    bgcolor=LightGray,
    fontsize=\scriptsize
  ]{XML}
<?xml version="1.0"?>
<?xml-model href="http://download.ros.org/schema/package_format3.xsd" schematypens="http://www.w3.org/2001/XMLSchema"?>
<package format="3">
  <name>br2_bt_bumpgo</name>
  <version>0.1.0</version>
  <description>Mastering Behavior Trees in ROS2</description>
  <maintainer email="fmrico@gmail.com">fmrico</maintainer>
  <license>Apache 2.0</license>

  <buildtool_depend>ament_cmake</buildtool_depend>

  <depend>rclcpp</depend>
  <depend>behaviortree_cpp_v3</depend>
  <depend>sensor_msgs</depend>
  <depend>geometry_msgs</depend>
  <depend>libzmq3-dev</depend>
  <depend>ament_index_cpp</depend>

  <test_depend>ament_lint_auto</test_depend>
  <test_depend>ament_lint_common</test_depend>
  <test_depend>ament_cmake_gtest</test_depend>

  <export>
    <build_type>ament_cmake</build_type>
  </export>
</package>
    \end{minted}
    \end{tcolorbox}
  \normalsize

 \footnotesize
\begin{tcolorbox}[sharp corners, colframe=gray!80, colback=LightGray, left=0pt, top=0pt, bottom=0pt, title=\texttt{br2\_bt\_bumpgo/include/br2\_bt\_bumpgo/Turn.hpp}]
  \begin{minted}[
    framesep=2mm,
    baselinestretch=0.8,
    bgcolor=LightGray,
    fontsize=\scriptsize
  ]{CPP}
// Copyright 2021 Intelligent Robotics Lab
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

#ifndef BR2_BT_BUMPGO__TURN_HPP_
#define BR2_BT_BUMPGO__TURN_HPP_

#include <string>

#include "behaviortree_cpp_v3/behavior_tree.h"
#include "behaviortree_cpp_v3/bt_factory.h"

#include "geometry_msgs/msg/twist.hpp"
#include "rclcpp/rclcpp.hpp"

namespace br2_bt_bumpgo
{

class Turn : public BT::ActionNodeBase
{
public:
  explicit Turn(
    const std::string & xml_tag_name,
    const BT::NodeConfiguration & conf);

  void halt();
  BT::NodeStatus tick();

  static BT::PortsList providedPorts()
  {
    return BT::PortsList({});
  }

private:
  rclcpp::Node::SharedPtr node_;
  rclcpp::Time start_time_;
  rclcpp::Publisher<geometry_msgs::msg::Twist>::SharedPtr vel_pub_;
};

}  // namespace br2_bt_bumpgo

#endif  // BR2_BT_BUMPGO__TURN_HPP_
    \end{minted}
    \end{tcolorbox}
  \normalsize

 \footnotesize
\begin{tcolorbox}[sharp corners, colframe=gray!80, colback=LightGray, left=0pt, top=0pt, bottom=0pt, title=\texttt{br2\_bt\_bumpgo/include/br2\_bt\_bumpgo/IsObstacle.hpp}]
  \begin{minted}[
    framesep=2mm,
    baselinestretch=0.8,
    bgcolor=LightGray,
    fontsize=\scriptsize
  ]{CPP}
// Copyright 2021 Intelligent Robotics Lab
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

#ifndef BR2_BT_BUMPGO__ISOBSTACLE_HPP_
#define BR2_BT_BUMPGO__ISOBSTACLE_HPP_

#include <string>

#include "behaviortree_cpp_v3/behavior_tree.h"
#include "behaviortree_cpp_v3/bt_factory.h"

#include "sensor_msgs/msg/laser_scan.hpp"
#include "rclcpp/rclcpp.hpp"

namespace br2_bt_bumpgo
{

class IsObstacle : public BT::ConditionNode
{
public:
  explicit IsObstacle(
    const std::string & xml_tag_name,
    const BT::NodeConfiguration & conf);

  BT::NodeStatus tick();

  static BT::PortsList providedPorts()
  {
    return BT::PortsList(
      {
        BT::InputPort<double>("distance")
      });
  }

  void laser_callback(sensor_msgs::msg::LaserScan::UniquePtr msg);

private:
  rclcpp::Node::SharedPtr node_;
  rclcpp::Time last_reading_time_;
  rclcpp::Subscription<sensor_msgs::msg::LaserScan>::SharedPtr laser_sub_;
  sensor_msgs::msg::LaserScan::UniquePtr last_scan_;
};

}  // namespace br2_bt_bumpgo

#endif  // BR2_BT_BUMPGO__ISOBSTACLE_HPP_
    \end{minted}
    \end{tcolorbox}
  \normalsize

 \footnotesize
\begin{tcolorbox}[sharp corners, colframe=gray!80, colback=LightGray, left=0pt, top=0pt, bottom=0pt, title=\texttt{br2\_bt\_bumpgo/include/br2\_bt\_bumpgo/Back.hpp}]
  \begin{minted}[
    framesep=2mm,
    baselinestretch=0.8,
    bgcolor=LightGray,
    fontsize=\scriptsize
  ]{CPP}
// Copyright 2021 Intelligent Robotics Lab
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

#ifndef BR2_BT_BUMPGO__BACK_HPP_
#define BR2_BT_BUMPGO__BACK_HPP_

#include <string>

#include "behaviortree_cpp_v3/behavior_tree.h"
#include "behaviortree_cpp_v3/bt_factory.h"

#include "geometry_msgs/msg/twist.hpp"
#include "rclcpp/rclcpp.hpp"

namespace br2_bt_bumpgo
{

class Back : public BT::ActionNodeBase
{
public:
  explicit Back(
    const std::string & xml_tag_name,
    const BT::NodeConfiguration & conf);

  void halt();
  BT::NodeStatus tick();

  static BT::PortsList providedPorts()
  {
    return BT::PortsList({});
  }

private:
  rclcpp::Node::SharedPtr node_;
  rclcpp::Time start_time_;
  rclcpp::Publisher<geometry_msgs::msg::Twist>::SharedPtr vel_pub_;
};

}  // namespace br2_bt_bumpgo

#endif  // BR2_BT_BUMPGO__BACK_HPP_
    \end{minted}
    \end{tcolorbox}
  \normalsize

 \footnotesize
\begin{tcolorbox}[sharp corners, colframe=gray!80, colback=LightGray, left=0pt, top=0pt, bottom=0pt, title=\texttt{br2\_bt\_bumpgo/include/br2\_bt\_bumpgo/Forward.hpp}]
  \begin{minted}[
    framesep=2mm,
    baselinestretch=0.8,
    bgcolor=LightGray,
    fontsize=\scriptsize
  ]{CPP}
// Copyright 2021 Intelligent Robotics Lab
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

#ifndef BR2_BT_BUMPGO__FORWARD_HPP_
#define BR2_BT_BUMPGO__FORWARD_HPP_

#include <string>

#include "behaviortree_cpp_v3/behavior_tree.h"
#include "behaviortree_cpp_v3/bt_factory.h"

#include "geometry_msgs/msg/twist.hpp"
#include "rclcpp/rclcpp.hpp"

namespace br2_bt_bumpgo
{

class Forward : public BT::ActionNodeBase
{
public:
  explicit Forward(
    const std::string & xml_tag_name,
    const BT::NodeConfiguration & conf);

  void halt() {}
  BT::NodeStatus tick();

  static BT::PortsList providedPorts()
  {
    return BT::PortsList({});
  }

private:
  rclcpp::Node::SharedPtr node_;
  rclcpp::Publisher<geometry_msgs::msg::Twist>::SharedPtr vel_pub_;
};

}  // namespace br2_bt_bumpgo

#endif  // BR2_BT_BUMPGO__FORWARD_HPP_
    \end{minted}
    \end{tcolorbox}
  \normalsize

 \footnotesize
\begin{tcolorbox}[sharp corners, colframe=gray!80, colback=LightGray, left=0pt, top=0pt, bottom=0pt, title=\texttt{br2\_bt\_bumpgo/src/bt\_bumpgo\_main.cpp}]
  \begin{minted}[
    framesep=2mm,
    baselinestretch=0.8,
    bgcolor=LightGray,
    fontsize=\scriptsize
  ]{CPP}
// Copyright 2021 Intelligent Robotics Lab
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

#include <string>
#include <memory>

#include "behaviortree_cpp_v3/behavior_tree.h"
#include "behaviortree_cpp_v3/bt_factory.h"
#include "behaviortree_cpp_v3/utils/shared_library.h"
#include "behaviortree_cpp_v3/loggers/bt_zmq_publisher.h"

#include "ament_index_cpp/get_package_share_directory.hpp"

#include "rclcpp/rclcpp.hpp"


int main(int argc, char * argv[])
{
  rclcpp::init(argc, argv);

  auto node = rclcpp::Node::make_shared("patrolling_node");

  BT::BehaviorTreeFactory factory;
  BT::SharedLibrary loader;

  factory.registerFromPlugin(loader.getOSName("br2_forward_bt_node"));
  factory.registerFromPlugin(loader.getOSName("br2_back_bt_node"));
  factory.registerFromPlugin(loader.getOSName("br2_turn_bt_node"));
  factory.registerFromPlugin(loader.getOSName("br2_is_obstacle_bt_node"));

  std::string pkgpath = ament_index_cpp::get_package_share_directory("br2_bt_bumpgo");
  std::string xml_file = pkgpath + "/behavior_tree_xml/bumpgo.xml";

  auto blackboard = BT::Blackboard::create();
  blackboard->set("node", node);
  BT::Tree tree = factory.createTreeFromFile(xml_file, blackboard);

  auto publisher_zmq = std::make_shared<BT::PublisherZMQ>(tree, 10, 1666, 1667);

  rclcpp::Rate rate(10);

  bool finish = false;
  while (!finish && rclcpp::ok()) {
    finish = tree.rootNode()->executeTick() != BT::NodeStatus::RUNNING;

    rclcpp::spin_some(node);
    rate.sleep();
  }

  rclcpp::shutdown();
  return 0;
}
    \end{minted}
    \end{tcolorbox}
  \normalsize

 \footnotesize
\begin{tcolorbox}[sharp corners, colframe=gray!80, colback=LightGray, left=0pt, top=0pt, bottom=0pt, title=\texttt{br2\_bt\_bumpgo/src/br2\_bt\_bumpgo/Back.cpp}]
  \begin{minted}[
    framesep=2mm,
    baselinestretch=0.8,
    bgcolor=LightGray,
    fontsize=\scriptsize
  ]{CPP}
// Copyright 2021 Intelligent Robotics Lab
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

#include <string>
#include <iostream>

#include "br2_bt_bumpgo/Back.hpp"

#include "behaviortree_cpp_v3/behavior_tree.h"

#include "geometry_msgs/msg/twist.hpp"
#include "rclcpp/rclcpp.hpp"

namespace br2_bt_bumpgo
{

using namespace std::chrono_literals;

Back::Back(
  const std::string & xml_tag_name,
  const BT::NodeConfiguration & conf)
: BT::ActionNodeBase(xml_tag_name, conf)
{
  config().blackboard->get("node", node_);

  vel_pub_ = node_->create_publisher<geometry_msgs::msg::Twist>("/output_vel", 100);
}

void
Back::halt()
{
}

BT::NodeStatus
Back::tick()
{
  if (status() == BT::NodeStatus::IDLE) {
    start_time_ = node_->now();
  }

  geometry_msgs::msg::Twist vel_msgs;
  vel_msgs.linear.x = -0.3;
  vel_pub_->publish(vel_msgs);

  auto elapsed = node_->now() - start_time_;

  if (elapsed < 3s) {
    return BT::NodeStatus::RUNNING;
  } else {
    return BT::NodeStatus::SUCCESS;
  }
}

}  // namespace br2_bt_bumpgo

#include "behaviortree_cpp_v3/bt_factory.h"
BT_REGISTER_NODES(factory)
{
  factory.registerNodeType<br2_bt_bumpgo::Back>("Back");
}
    \end{minted}
    \end{tcolorbox}
  \normalsize

 \footnotesize
\begin{tcolorbox}[sharp corners, colframe=gray!80, colback=LightGray, left=0pt, top=0pt, bottom=0pt, title=\texttt{br2\_bt\_bumpgo/src/br2\_bt\_bumpgo/Forward.cpp}]
  \begin{minted}[
    framesep=2mm,
    baselinestretch=0.8,
    bgcolor=LightGray,
    fontsize=\scriptsize
  ]{CPP}
// Copyright 2021 Intelligent Robotics Lab
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

#include <string>
#include <iostream>

#include "br2_bt_bumpgo/Forward.hpp"

#include "behaviortree_cpp_v3/behavior_tree.h"

#include "geometry_msgs/msg/twist.hpp"
#include "rclcpp/rclcpp.hpp"

namespace br2_bt_bumpgo
{

using namespace std::chrono_literals;

Forward::Forward(
  const std::string & xml_tag_name,
  const BT::NodeConfiguration & conf)
: BT::ActionNodeBase(xml_tag_name, conf)
{
  config().blackboard->get("node", node_);

  vel_pub_ = node_->create_publisher<geometry_msgs::msg::Twist>("/output_vel", 100);
}

BT::NodeStatus
Forward::tick()
{
  geometry_msgs::msg::Twist vel_msgs;
  vel_msgs.linear.x = 0.3;
  vel_pub_->publish(vel_msgs);

  return BT::NodeStatus::RUNNING;
}

}  // namespace br2_bt_bumpgo

#include "behaviortree_cpp_v3/bt_factory.h"
BT_REGISTER_NODES(factory)
{
  factory.registerNodeType<br2_bt_bumpgo::Forward>("Forward");
}
    \end{minted}
    \end{tcolorbox}
  \normalsize

 \footnotesize
\begin{tcolorbox}[sharp corners, colframe=gray!80, colback=LightGray, left=0pt, top=0pt, bottom=0pt, title=\texttt{br2\_bt\_bumpgo/src/br2\_bt\_bumpgo/IsObstacle.cpp}]
  \begin{minted}[
    framesep=2mm,
    baselinestretch=0.8,
    bgcolor=LightGray,
    fontsize=\scriptsize
  ]{CPP}
// Copyright 2021 Intelligent Robotics Lab
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

#include <string>
#include <utility>

#include "br2_bt_bumpgo/IsObstacle.hpp"

#include "behaviortree_cpp_v3/behavior_tree.h"

#include "sensor_msgs/msg/laser_scan.hpp"
#include "rclcpp/rclcpp.hpp"

namespace br2_bt_bumpgo
{

using namespace std::chrono_literals;
using namespace std::placeholders;

IsObstacle::IsObstacle(
  const std::string & xml_tag_name,
  const BT::NodeConfiguration & conf)
: BT::ConditionNode(xml_tag_name, conf)
{
  config().blackboard->get("node", node_);

  laser_sub_ = node_->create_subscription<sensor_msgs::msg::LaserScan>(
    "/input_scan", 100, std::bind(&IsObstacle::laser_callback, this, _1));

  last_reading_time_ = node_->now();
}

void
IsObstacle::laser_callback(sensor_msgs::msg::LaserScan::UniquePtr msg)
{
  last_scan_ = std::move(msg);
}

BT::NodeStatus
IsObstacle::tick()
{
  if (last_scan_ == nullptr) {
    return BT::NodeStatus::FAILURE;
  }

  double distance = 1.0;
  getInput("distance", distance);

  if (last_scan_->ranges[last_scan_->ranges.size() / 2] < distance) {
    return BT::NodeStatus::SUCCESS;
  } else {
    return BT::NodeStatus::FAILURE;
  }
}

}  // namespace br2_bt_bumpgo

#include "behaviortree_cpp_v3/bt_factory.h"
BT_REGISTER_NODES(factory)
{
  factory.registerNodeType<br2_bt_bumpgo::IsObstacle>("IsObstacle");
}
    \end{minted}
    \end{tcolorbox}
  \normalsize

 \footnotesize
\begin{tcolorbox}[sharp corners, colframe=gray!80, colback=LightGray, left=0pt, top=0pt, bottom=0pt, title=\texttt{br2\_bt\_bumpgo/src/br2\_bt\_bumpgo/Turn.cpp}]
  \begin{minted}[
    framesep=2mm,
    baselinestretch=0.8,
    bgcolor=LightGray,
    fontsize=\scriptsize
  ]{CPP}
// Copyright 2021 Intelligent Robotics Lab
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

#include <string>
#include <iostream>

#include "br2_bt_bumpgo/Turn.hpp"

#include "behaviortree_cpp_v3/behavior_tree.h"

#include "geometry_msgs/msg/twist.hpp"
#include "rclcpp/rclcpp.hpp"

namespace br2_bt_bumpgo
{

using namespace std::chrono_literals;

Turn::Turn(
  const std::string & xml_tag_name,
  const BT::NodeConfiguration & conf)
: BT::ActionNodeBase(xml_tag_name, conf)
{
  config().blackboard->get("node", node_);

  vel_pub_ = node_->create_publisher<geometry_msgs::msg::Twist>("/output_vel", 100);
}

void
Turn::halt()
{
}

BT::NodeStatus
Turn::tick()
{
  if (status() == BT::NodeStatus::IDLE) {
    start_time_ = node_->now();
  }

  geometry_msgs::msg::Twist vel_msgs;
  vel_msgs.angular.z = 0.5;
  vel_pub_->publish(vel_msgs);

  auto elapsed = node_->now() - start_time_;

  if (elapsed < 3s) {
    return BT::NodeStatus::RUNNING;
  } else {
    return BT::NodeStatus::SUCCESS;
  }
}

}  // namespace br2_bt_bumpgo

#include "behaviortree_cpp_v3/bt_factory.h"
BT_REGISTER_NODES(factory)
{
  factory.registerNodeType<br2_bt_bumpgo::Turn>("Turn");
}
    \end{minted}
    \end{tcolorbox}
  \normalsize

 \footnotesize
\begin{tcolorbox}[sharp corners, colframe=gray!80, colback=LightGray, left=0pt, top=0pt, bottom=0pt, title=\texttt{br2\_bt\_bumpgo/tests/bt\_action\_test.cpp}]
  \begin{minted}[
    framesep=2mm,
    baselinestretch=0.8,
    bgcolor=LightGray,
    fontsize=\scriptsize
  ]{CPP}
// Copyright 2021 Intelligent Robotics Lab
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

#include <string>
#include <list>
#include <memory>
#include <vector>
#include <set>

#include "behaviortree_cpp_v3/behavior_tree.h"
#include "behaviortree_cpp_v3/bt_factory.h"
#include "behaviortree_cpp_v3/utils/shared_library.h"

#include "ament_index_cpp/get_package_share_directory.hpp"

#include "geometry_msgs/msg/twist.hpp"
#include "sensor_msgs/msg/laser_scan.hpp"

#include "rclcpp/rclcpp.hpp"
#include "rclcpp_action/rclcpp_action.hpp"

#include "gtest/gtest.h"

using namespace std::placeholders;
using namespace std::chrono_literals;


class VelocitySinkNode : public rclcpp::Node
{
public:
  VelocitySinkNode()
  : Node("VelocitySink")
  {
    vel_sub_ = create_subscription<geometry_msgs::msg::Twist>(
      "/output_vel", 100, std::bind(&VelocitySinkNode::vel_callback, this, _1));
  }

  void vel_callback(geometry_msgs::msg::Twist::SharedPtr msg)
  {
    vel_msgs_.push_back(*msg);
  }

  std::list<geometry_msgs::msg::Twist> vel_msgs_;

private:
  rclcpp::Subscription<geometry_msgs::msg::Twist>::SharedPtr vel_sub_;
};


TEST(bt_action, turn_btn)
{
  auto node = rclcpp::Node::make_shared("turn_btn_node");
  auto node_sink = std::make_shared<VelocitySinkNode>();

  BT::BehaviorTreeFactory factory;
  BT::SharedLibrary loader;

  factory.registerFromPlugin(loader.getOSName("br2_turn_bt_node"));

  std::string xml_bt =
    R"(
    <root main_tree_to_execute = "MainTree" >
      <BehaviorTree ID="MainTree">
          <Turn />
      </BehaviorTree>
    </root>)";

  auto blackboard = BT::Blackboard::create();
  blackboard->set("node", node);
  BT::Tree tree = factory.createTreeFromText(xml_bt, blackboard);

  rclcpp::Rate rate(10);
  bool finish = false;
  while (!finish && rclcpp::ok()) {
    finish = tree.rootNode()->executeTick() == BT::NodeStatus::SUCCESS;
    rclcpp::spin_some(node_sink);
    rate.sleep();
  }

  ASSERT_FALSE(node_sink->vel_msgs_.empty());
  ASSERT_NEAR(node_sink->vel_msgs_.size(), 30, 1);

  geometry_msgs::msg::Twist & one_twist = node_sink->vel_msgs_.front();

  ASSERT_GT(one_twist.angular.z, 0.1);
  ASSERT_NEAR(one_twist.linear.x, 0.0, 0.0000001);
}

TEST(bt_action, back_btn)
{
  auto node = rclcpp::Node::make_shared("back_btn_node");
  auto node_sink = std::make_shared<VelocitySinkNode>();

  BT::BehaviorTreeFactory factory;
  BT::SharedLibrary loader;

  factory.registerFromPlugin(loader.getOSName("br2_back_bt_node"));

  std::string xml_bt =gte_node
    R"(
    <root main_tree_to_execute = "MainTree" >
      <BehaviorTree ID="MainTree">
          <Back />
      </BehaviorTree>
    </root>)";

  auto blackboard = BT::Blackboard::create();
  blackboard->set("node", node);
  BT::Tree tree = factory.createTreeFromText(xml_bt, blackboard);

  rclcpp::Rate rate(10);
  bool finish = false;
  while (!finish && rclcpp::ok()) {
    finish = tree.rootNode()->executeTick() == BT::NodeStatus::SUCCESS;
    rclcpp::spin_some(node_sink);
    rate.sleep();
  }

  ASSERT_FALSE(node_sink->vel_msgs_.empty());
  ASSERT_NEAR(node_sink->vel_msgs_.size(), 30, 1);

  geometry_msgs::msg::Twist & one_twist = node_sink->vel_msgs_.front();

  ASSERT_LT(one_twist.linear.x, -0.1);
  ASSERT_NEAR(one_twist.angular.z, 0.0, 0.0000001);
}

TEST(bt_action, forward_btn)
{
  auto node = rclcpp::Node::make_shared("forward_btn_node");
  auto node_sink = std::make_shared<VelocitySinkNode>();

  BT::BehaviorTreeFactory factory;
  BT::SharedLibrary loader;

  factory.registerFromPlugin(loader.getOSName("br2_forward_bt_node"));

  std::string xml_bt =
    R"(
    <root main_tree_to_execute = "MainTree" >
      <BehaviorTree ID="MainTree">
          <Forward />
      </BehaviorTree>
    </root>)";

  auto blackboard = BT::Blackboard::create();
  blackboard->set("node", node);
  BT::Tree tree = factory.createTreeFromText(xml_bt, blackboard);

  rclcpp::Rate rate(10);
  auto current_status = BT::NodeStatus::FAILURE;
  int counter = 0;
  while (counter++ < 30 && rclcpp::ok()) {
    current_status = tree.rootNode()->executeTick();
    rclcpp::spin_some(node_sink);
    rate.sleep();
  }

  ASSERT_EQ(current_status, BT::NodeStatus::RUNNING);
  ASSERT_FALSE(node_sink->vel_msgs_.empty());
  ASSERT_NEAR(node_sink->vel_msgs_.size(), 30, 1);

  geometry_msgs::msg::Twist & one_twist = node_sink->vel_msgs_.front();

  ASSERT_GT(one_twist.linear.x, 0.1);
  ASSERT_NEAR(one_twist.angular.z, 0.0, 0.0000001);
}

TEST(bt_action, is_obstacle_btn)
{
  auto node = rclcpp::Node::make_shared("is_obstacle_btn_node");
  auto scan_pub = node->create_publisher<sensor_msgs::msg::LaserScan>("input_scan", 1);

  BT::BehaviorTreeFactory factory;
  BT::SharedLibrary loader;

  factory.registerFromPlugin(loader.getOSName("br2_is_obstacle_bt_node"));

  std::string xml_bt =
    R"(
    <root main_tree_to_execute = "MainTree" >
      <BehaviorTree ID="MainTree">
          <IsObstacle/>
      </BehaviorTree>
    </root>)";

  auto blackboard = BT::Blackboard::create();
  blackboard->set("node", node);
  BT::Tree tree = factory.createTreeFromText(xml_bt, blackboard);

  rclcpp::Rate rate(10);

  sensor_msgs::msg::LaserScan scan;
  scan.ranges.push_back(2.0);
  for (int i = 0; i < 10; i++) {
    scan_pub->publish(scan);
    rclcpp::spin_some(node);
    rate.sleep();
  }

  BT::NodeStatus current_status = tree.rootNode()->executeTick();
  ASSERT_EQ(current_status, BT::NodeStatus::FAILURE);

  scan.ranges[0] = 0.3;
  for (int i = 0; i < 10; i++) {
    scan_pub->publish(scan);
    rclcpp::spin_some(node);
    rate.sleep();
  }

  current_status = tree.rootNode()->executeTick();
  ASSERT_EQ(current_status, BT::NodeStatus::SUCCESS);

  xml_bt =
    R"(
    <root main_tree_to_execute = "MainTree" >
      <BehaviorTree ID="MainTree">
          <IsObstacle distance="0.5"/>
      </BehaviorTree>
    </root>)";
  tree = factory.createTreeFromText(xml_bt, blackboard);

  scan.ranges[0] = 0.3;
  for (int i = 0; i < 10; i++) {
    scan_pub->publish(scan);
    rclcpp::spin_some(node);
    rate.sleep();
  }

  current_status = tree.rootNode()->executeTick();
  ASSERT_EQ(current_status, BT::NodeStatus::SUCCESS);

  scan.ranges[0] = 0.6;
  for (int i = 0; i < 10; i++) {
    scan_pub->publish(scan);
    rclcpp::spin_some(node);
    rate.sleep();
  }

  current_status = tree.rootNode()->executeTick();
  ASSERT_EQ(current_status, BT::NodeStatus::FAILURE);
}

int main(int argc, char ** argv)
{
  rclcpp::init(argc, argv);

  testing::InitGoogleTest(&argc, argv);
  return RUN_ALL_TESTS();
}
    \end{minted}
    \end{tcolorbox}
  \normalsize

 \footnotesize
\begin{tcolorbox}[sharp corners, colframe=gray!80, colback=LightGray, left=0pt, top=0pt, bottom=0pt, title=\texttt{br2\_bt\_bumpgo/tests/CMakeLists.txt}]
  \begin{minted}[
    framesep=2mm,
    baselinestretch=0.8,
    bgcolor=LightGray,
    fontsize=\scriptsize
  ]{CMake}

ament_add_gtest(bt_action_test bt_action_test.cpp)
ament_target_dependencies(bt_action_test ${dependencies})

add_executable(bt_forward bt_forward_main.cpp)
ament_target_dependencies(bt_forward ${dependencies})
target_link_libraries(bt_forward ${ZMQ_LIBRARIES})

install(TARGETS
  bt_forward
  ARCHIVE DESTINATION lib
  LIBRARY DESTINATION lib
  RUNTIME DESTINATION lib/${PROJECT_NAME}
)
    \end{minted}
    \end{tcolorbox}
  \normalsize

 \footnotesize
\begin{tcolorbox}[sharp corners, colframe=gray!80, colback=LightGray, left=0pt, top=0pt, bottom=0pt, title=\texttt{br2\_bt\_bumpgo/tests/bt\_forward\_main.cpp}]
  \begin{minted}[
    framesep=2mm,
    baselinestretch=0.8,
    bgcolor=LightGray,
    fontsize=\scriptsize
  ]{CPP}
// Copyright 2021 Intelligent Robotics Lab
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

#include <string>
#include <memory>

#include "behaviortree_cpp_v3/behavior_tree.h"
#include "behaviortree_cpp_v3/bt_factory.h"
#include "behaviortree_cpp_v3/utils/shared_library.h"
#include "behaviortree_cpp_v3/loggers/bt_zmq_publisher.h"

#include "ament_index_cpp/get_package_share_directory.hpp"

#include "rclcpp/rclcpp.hpp"


int main(int argc, char * argv[])
{
  rclcpp::init(argc, argv);

  auto node = rclcpp::Node::make_shared("forward_node");

  BT::BehaviorTreeFactory factory;
  BT::SharedLibrary loader;

  factory.registerFromPlugin(loader.getOSName("br2_forward_bt_node"));

  std::string xml_bt =
    R"(
    <root main_tree_to_execute = "MainTree" >
      <BehaviorTree ID="MainTree">
          <Forward />
      </BehaviorTree>
    </root>)";

  auto blackboard = BT::Blackboard::create();
  blackboard->set("node", node);
  BT::Tree tree = factory.createTreeFromText(xml_bt, blackboard);

  rclcpp::Rate rate(10);
  bool finish = false;
  while (!finish && rclcpp::ok()) {
    finish = tree.rootNode()->executeTick() != BT::NodeStatus::RUNNING;

    rclcpp::spin_some(node);
    rate.sleep();
  }

  rclcpp::shutdown();
  return 0;
}
    \end{minted}
    \end{tcolorbox}
  \normalsize



\appendix

\chapter[Source Code]{Source Code}
\label{cap:source}
Complete list of source code used in the book, also available in:

\vspace{0.5cm}
\large
\texttt{https://github.com/fmrico/book\_ros2}
\normalsize
)
\section{Package \texttt{br2\_bt\_patrolling}}
\label{sec:anex:br2_bt_patrolling}

 \footnotesize
\begin{tcolorbox}[sharp corners, colframe=gray!80, colback=LightGray, left=0pt, top=0pt, bottom=0pt, title=Package \texttt{br2\_bt\_patrolling}]
  \begin{minted}[
    framesep=2mm,
    baselinestretch=0.8,
    bgcolor=LightGreen,
    fontsize=\scriptsize
  ]{console}
br2_bt_patrolling
├── behavior_tree_xml
│   └── patrolling.xml
├── cmake
│   └── FindZMQ.cmake
├── CMakeLists.txt
├── include
│   └── br2_bt_patrolling
│       ├── BatteryChecker.hpp
│       ├── ctrl_support
│       │   ├── BTActionNode.hpp
│       │   └── BTLifecycleCtrlNode.hpp
│       ├── GetWaypoint.hpp
│       ├── Move.hpp
│       ├── Patrol.hpp
│       ├── Recharge.hpp
│       └── TrackObjects.hpp
├── launch
│   └── patrolling.launch.py
├── package.xml
├── src
│   ├── br2_bt_patrolling
│   │   ├── BatteryChecker.cpp
│   │   ├── GetWaypoint.cpp
│   │   ├── Move.cpp
│   │   ├── Patrol.cpp
│   │   ├── Recharge.cpp
│   │   └── TrackObjects.cpp
│   └── patrolling_main.cpp
└── tests
    ├── bt_action_test.cpp
    └── CMakeLists.txt    \end{minted}
    \end{tcolorbox}
  \normalsize

 \footnotesize
\begin{tcolorbox}[sharp corners, colframe=gray!80, colback=LightGray, left=0pt, top=0pt, bottom=0pt, title=\texttt{br2\_bt\_patrolling/behavior\_tree\_xml/patrolling.xml}]
  \begin{minted}[
    framesep=2mm,
    baselinestretch=0.8,
    bgcolor=LightGray,
    fontsize=\scriptsize
  ]{XML}
<?xml version="1.0"?>
<root main_tree_to_execute="BehaviorTree">
    <!-- ////////// -->
    <BehaviorTree ID="BehaviorTree">
        <KeepRunningUntilFailure>
            <ReactiveSequence>
                <Fallback>
                    <Action ID="BatteryChecker"/>
                    <Sequence>
                        <Action ID="GetWaypoint" waypoint="{recharge_wp}" wp_id="recharge"/>
                        <Action ID="Move" goal="{recharge_wp}"/>
                        <Action ID="Recharge"/>
                    </Sequence>
                </Fallback>
                <Sequence>
                    <Action ID="GetWaypoint" waypoint="{wp}" wp_id="next"/>
                        <Parallel success_threshold="1" failure_threshold="1">
                          <Action ID="TrackObjects"/>
                          <Action ID="Move" goal="{wp}"/>
                        </Parallel>
                    <Action ID="Patrol"/>
                </Sequence>
            </ReactiveSequence>
        </KeepRunningUntilFailure>
    </BehaviorTree>
    <!-- ////////// -->
    <TreeNodesModel>
        <Action ID="BatteryChecker"/>
        <Action ID="GetWaypoint">
            <output_port name="waypoint"/>
            <input_port name="wp_id"/>
        </Action>
        <Action ID="Move">
            <input_port name="goal"/>
        </Action>
        <Action ID="Patrol"/>
        <Action ID="Recharge"/>
        <Action ID="TrackObjects"/>
    </TreeNodesModel>
    <!-- ////////// -->
</root>

    \end{minted}
    \end{tcolorbox}
  \normalsize

 \footnotesize
\begin{tcolorbox}[sharp corners, colframe=gray!80, colback=LightGray, left=0pt, top=0pt, bottom=0pt, title=\texttt{br2\_bt\_patrolling/CMakeLists.txt}]
  \begin{minted}[
    framesep=2mm,
    baselinestretch=0.8,
    bgcolor=LightGray,
    fontsize=\scriptsize
  ]{CMake}
cmake_minimum_required(VERSION 3.5)
project(br2_bt_patrolling)

set(CMAKE_BUILD_TYPE Debug)

set(CMAKE_CONFIG_PATH ${CMAKE_MODULE_PATH}  "${CMAKE_CURRENT_LIST_DIR}/cmake")
list(APPEND CMAKE_MODULE_PATH "${CMAKE_CONFIG_PATH}")

find_package(ament_cmake REQUIRED)
find_package(rclcpp REQUIRED)
find_package(rclcpp_lifecycle REQUIRED)
find_package(rclcpp_action REQUIRED)
find_package(behaviortree_cpp_v3 REQUIRED)
find_package(action_msgs REQUIRED)
find_package(lifecycle_msgs REQUIRED)
find_package(geometry_msgs REQUIRED)
find_package(nav2_msgs REQUIRED)
find_package(ament_index_cpp REQUIRED)

find_package(ZMQ)
if(ZMQ_FOUND)
    message(STATUS "ZeroMQ found.")
    add_definitions(-DZMQ_FOUND)
else()
  message(WARNING "ZeroMQ NOT found. Not including PublisherZMQ.")
endif()

set(CMAKE_CXX_STANDARD 17)

set(dependencies
    rclcpp
    rclcpp_lifecycle
    rclcpp_action
    behaviortree_cpp_v3
    action_msgs
    lifecycle_msgs
    geometry_msgs
    nav2_msgs
    ament_index_cpp
)

include_directories(include ${ZMQ_INCLUDE_DIRS})

add_library(br2_recharge_bt_node SHARED src/br2_bt_patrolling/Recharge.cpp)
add_library(br2_patrol_bt_node SHARED src/br2_bt_patrolling/Patrol.cpp)
add_library(br2_move_bt_node SHARED src/br2_bt_patrolling/Move.cpp)
add_library(br2_get_waypoint_bt_node SHARED src/br2_bt_patrolling/GetWaypoint.cpp)
add_library(br2_battery_checker_bt_node SHARED src/br2_bt_patrolling/BatteryChecker.cpp)
add_library(br2_track_objects_bt_node SHARED src/br2_bt_patrolling/TrackObjects.cpp)
list(APPEND plugin_libs
  br2_recharge_bt_node
  br2_patrol_bt_node
  br2_move_bt_node
  br2_get_waypoint_bt_node
  br2_battery_checker_bt_node
  br2_track_objects_bt_node
)

foreach(bt_plugin ${plugin_libs})
  ament_target_dependencies(${bt_plugin} ${dependencies})
  target_compile_definitions(${bt_plugin} PRIVATE BT_PLUGIN_EXPORT)
endforeach()

add_executable(patrolling_main src/patrolling_main.cpp)
ament_target_dependencies(patrolling_main ${dependencies})
target_link_libraries(patrolling_main ${ZMQ_LIBRARIES})

install(TARGETS
  ${plugin_libs}
  patrolling_main
  ARCHIVE DESTINATION lib
  LIBRARY DESTINATION lib
  RUNTIME DESTINATION lib/${PROJECT_NAME}
)

install(DIRECTORY include/
  DESTINATION include/
)

install(DIRECTORY behavior_tree_xml launch
  DESTINATION share/${PROJECT_NAME}
)


if(BUILD_TESTING)
  find_package(ament_lint_auto REQUIRED)
  ament_lint_auto_find_test_dependencies()

  set(ament_cmake_cpplint_FOUND TRUE)
  ament_lint_auto_find_test_dependencies()

  find_package(ament_cmake_gtest REQUIRED)

  add_subdirectory(tests)
endif()

ament_export_include_directories(include)
ament_export_dependencies(${dependencies})

ament_package()
    \end{minted}
    \end{tcolorbox}
  \normalsize

 \footnotesize
\begin{tcolorbox}[sharp corners, colframe=gray!80, colback=LightGray, left=0pt, top=0pt, bottom=0pt, title=\texttt{br2\_bt\_patrolling/launch/patrolling.launch.py}]
  \begin{minted}[
    framesep=2mm,
    baselinestretch=0.8,
    bgcolor=LightGray,
    fontsize=\scriptsize
  ]{Python}
# Copyright 2021 Intelligent Robotics Lab
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import os

from ament_index_python.packages import get_package_share_directory

from launch import LaunchDescription
from launch.actions import IncludeLaunchDescription
from launch.launch_description_sources import PythonLaunchDescriptionSource
from launch_ros.actions import Node


def generate_launch_description():

    tracking_dir = get_package_share_directory('br2_tracking')

    tracking_cmd = IncludeLaunchDescription(
        PythonLaunchDescriptionSource(os.path.join(tracking_dir, 'launch', 'tracking.launch.py')))

    patrolling_cmd = Node(
        package='br2_bt_patrolling',
        executable='patrolling_main',
        parameters=[{
          'use_sim_time': True
        }],
        remappings=[
          ('input_scan', '/scan_raw'),
          ('output_vel', '/nav_vel')
        ],
        output='screen'
    )

    ld = LaunchDescription()

    # Add any actions
    ld.add_action(tracking_cmd)
    ld.add_action(patrolling_cmd)

    return ld
    \end{minted}
    \end{tcolorbox}
  \normalsize

 \footnotesize
\begin{tcolorbox}[sharp corners, colframe=gray!80, colback=LightGray, left=0pt, top=0pt, bottom=0pt, title=\texttt{br2\_bt\_patrolling/cmake/FindZMQ.cmake}]
  \begin{minted}[
    framesep=2mm,
    baselinestretch=0.8,
    bgcolor=LightGray,
    fontsize=\scriptsize
  ]{CMake}
# - Try to find ZMQ
# Once done this will define
#
#  ZMQ_FOUND - system has ZMQ
#  ZMQ_INCLUDE_DIRS - the ZMQ include directory
#  ZMQ_LIBRARIES - Link these to use ZMQ
#  ZMQ_DEFINITIONS - Compiler switches required for using ZMQ
#
#  Copyright (c) 2011 Lee Hambley <lee.hambley@gmail.com>
#
#  All rights reserved.
#
#  Software License Agreement (BSD License 2.0)
#
#  Redistribution and use in source and binary forms, with or without
#  modification, are permitted provided that the following conditions
#  are met:
#
#   * Redistributions of source code must retain the above copyright
#     notice, this list of conditions and the following disclaimer.
#   * Redistributions in binary form must reproduce the above
#     copyright notice, this list of conditions and the following
#     disclaimer in the documentation and/or other materials provided
#     with the distribution.
#   * Neither the name of {copyright_holder} nor the names of its
#     contributors may be used to endorse or promote products derived
#     from this software without specific prior written permission.
#
#  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
#  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
#  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
#  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
#  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
#  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
#  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
#  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
#  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
#  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
#  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
#  POSSIBILITY OF SUCH DAMAGE.


if(ZMQ_LIBRARIES AND ZMQ_INCLUDE_DIRS)
  # in cache already
  set(ZMQ_FOUND TRUE)
else()

  find_path(ZMQ_INCLUDE_DIR
    NAMES
      zmq.h
    PATHS
      /usr/include
      /usr/local/include
      /opt/local/include
      /sw/include
  )

  find_library(ZMQ_LIBRARY
    NAMES
      zmq
    PATHS
      /usr/lib
      /usr/local/lib
      /opt/local/lib
      /sw/lib
  )

  set(ZMQ_INCLUDE_DIRS
    ${ZMQ_INCLUDE_DIR}
  )

  if(ZMQ_LIBRARY)
    set(ZMQ_LIBRARIES
        ${ZMQ_LIBRARIES}
        ${ZMQ_LIBRARY}
    )
  endif()

  include(FindPackageHandleStandardArgs)
  find_package_handle_standard_args(ZMQ DEFAULT_MSG ZMQ_LIBRARIES ZMQ_INCLUDE_DIRS)

  # show the ZMQ_INCLUDE_DIRS and ZMQ_LIBRARIES variables only in the advanced view
  mark_as_advanced(ZMQ_INCLUDE_DIRS ZMQ_LIBRARIES)

endif()

    \end{minted}
    \end{tcolorbox}
  \normalsize

 \footnotesize
\begin{tcolorbox}[sharp corners, colframe=gray!80, colback=LightGray, left=0pt, top=0pt, bottom=0pt, title=\texttt{br2\_bt\_patrolling/package.xml}]
  \begin{minted}[
    framesep=2mm,
    baselinestretch=0.8,
    bgcolor=LightGray,
    fontsize=\scriptsize
  ]{XML}
<?xml version="1.0"?>
<?xml-model href="http://download.ros.org/schema/package_format3.xsd" schematypens="http://www.w3.org/2001/XMLSchema"?>
<package format="3">
  <name>br2_bt_patrolling</name>
  <version>0.1.0</version>
  <description>Mastering Behavior Trees in ROS2</description>
  <maintainer email="fmrico@gmail.com">fmrico</maintainer>
  <license>Apache 2.0</license>

  <buildtool_depend>ament_cmake</buildtool_depend>

  <depend>rclcpp</depend>
  <depend>rclcpp_lifecycle</depend>
  <depend>rclcpp_action</depend>
  <depend>behaviortree_cpp_v3</depend>
  <depend>action_msgs</depend>
  <depend>geometry_msgs</depend>
  <depend>lifecycle_msgs</depend>
  <depend>nav2_msgs</depend>
  <depend>libzmq3-dev</depend>
  <depend>ament_index_cpp</depend>

  <test_depend>ament_lint_auto</test_depend>
  <test_depend>ament_lint_common</test_depend>
  <test_depend>ament_cmake_gtest</test_depend>

  <export>
    <build_type>ament_cmake</build_type>
  </export>
</package>
    \end{minted}
    \end{tcolorbox}
  \normalsize

 \footnotesize
\begin{tcolorbox}[sharp corners, colframe=gray!80, colback=LightGray, left=0pt, top=0pt, bottom=0pt, title=\texttt{br2\_bt\_patrolling/include/br2\_bt\_patrolling/BatteryChecker.hpp}]
  \begin{minted}[
    framesep=2mm,
    baselinestretch=0.8,
    bgcolor=LightGray,
    fontsize=\scriptsize
  ]{CPP}
// Copyright 2021 Intelligent Robotics Lab
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

#ifndef BR2_BT_PATROLLING__BATTERYCHECKER_HPP_
#define BR2_BT_PATROLLING__BATTERYCHECKER_HPP_

#include <string>
#include <vector>

#include "behaviortree_cpp_v3/behavior_tree.h"
#include "behaviortree_cpp_v3/bt_factory.h"

#include "geometry_msgs/msg/twist.hpp"

#include "rclcpp/rclcpp.hpp"

namespace br2_bt_patrolling
{

class BatteryChecker : public BT::ConditionNode
{
public:
  explicit BatteryChecker(
    const std::string & xml_tag_name,
    const BT::NodeConfiguration & conf);

  BT::NodeStatus tick();

  static BT::PortsList providedPorts()
  {
    return BT::PortsList({});
  }

  void vel_callback(const geometry_msgs::msg::Twist::SharedPtr msg);

  const float DECAY_LEVEL = 0.5;  // 0.5 * |vel| * dt
  const float EPSILON = 0.01;  // 0.001 * dt
  const float MIN_LEVEL = 10.0;

private:
  void update_battery();

  rclcpp::Node::SharedPtr node_;
  rclcpp::Time last_reading_time_;
  geometry_msgs::msg::Twist last_twist_;
  rclcpp::Subscription<geometry_msgs::msg::Twist>::SharedPtr vel_sub_;
};

}  // namespace br2_bt_patrolling

#endif  // BR2_BT_PATROLLING__BATTERYCHECKER_HPP_
    \end{minted}
    \end{tcolorbox}
  \normalsize

 \footnotesize
\begin{tcolorbox}[sharp corners, colframe=gray!80, colback=LightGray, left=0pt, top=0pt, bottom=0pt, title=\texttt{br2\_bt\_patrolling/include/br2\_bt\_patrolling/ctrl\_support/BTLifecycleCtrlNode.hpp}]
  \begin{minted}[
    framesep=2mm,
    baselinestretch=0.8,
    bgcolor=LightGray,
    fontsize=\scriptsize
  ]{CPP}
// Copyright (c) 2018 Intel Corporation
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

#ifndef BR2_BT_PATROLLING__CTRL_SUPPORT__BTLIFECYCLECTRLNODE_HPP_
#define BR2_BT_PATROLLING__CTRL_SUPPORT__BTLIFECYCLECTRLNODE_HPP_

#include <memory>
#include <string>

#include "lifecycle_msgs/srv/change_state.hpp"
#include "lifecycle_msgs/srv/get_state.hpp"
#include "lifecycle_msgs/msg/state.hpp"

#include "behaviortree_cpp_v3/action_node.h"
#include "rclcpp/rclcpp.hpp"

namespace br2_bt_patrolling
{

using namespace std::chrono_literals;  // NOLINT

class BtLifecycleCtrlNode : public BT::ActionNodeBase
{
public:
  BtLifecycleCtrlNode(
    const std::string & xml_tag_name,
    const std::string & node_name,
    const BT::NodeConfiguration & conf)
  : BT::ActionNodeBase(xml_tag_name, conf), ctrl_node_name_(node_name)
  {
    node_ = config().blackboard->get<rclcpp::Node::SharedPtr>("node");
  }

  BtLifecycleCtrlNode() = delete;

  virtual ~BtLifecycleCtrlNode()
  {
  }

  template<typename serviceT>
  typename rclcpp::Client<serviceT>::SharedPtr createServiceClient(const std::string & service_name)
  {
    auto srv = node_->create_client<serviceT>(service_name);
    while (!srv->wait_for_service(1s)) {
      if (!rclcpp::ok()) {
        RCLCPP_ERROR(node_->get_logger(), "Interrupted while waiting for the service. Exiting.");
      } else {
        RCLCPP_INFO(node_->get_logger(), "service not available, waiting again...");
      }
    }
    return srv;
  }

  virtual void on_tick() {}

  virtual BT::NodeStatus on_success()
  {
    return BT::NodeStatus::SUCCESS;
  }

  virtual BT::NodeStatus on_failure()
  {
    return BT::NodeStatus::FAILURE;
  }

  BT::NodeStatus tick() override
  {
    if (status() == BT::NodeStatus::IDLE) {
      change_state_client_ = createServiceClient<lifecycle_msgs::srv::ChangeState>(
        ctrl_node_name_ + "/change_state");
      get_state_client_ = createServiceClient<lifecycle_msgs::srv::GetState>(
        ctrl_node_name_ + "/get_state");
    }

    if (ctrl_node_state_ != lifecycle_msgs::msg::State::PRIMARY_STATE_ACTIVE) {
      ctrl_node_state_ = get_state();
      set_state(lifecycle_msgs::msg::State::PRIMARY_STATE_ACTIVE);
    }

    on_tick();

    return BT::NodeStatus::RUNNING;
  }

  void halt() override
  {
    if (ctrl_node_state_ == lifecycle_msgs::msg::State::PRIMARY_STATE_ACTIVE) {
      set_state(lifecycle_msgs::msg::State::PRIMARY_STATE_INACTIVE);
    }
    setStatus(BT::NodeStatus::IDLE);
  }

  // Get the state of the controlled node
  uint8_t get_state()
  {
    auto request = std::make_shared<lifecycle_msgs::srv::GetState::Request>();
    auto result = get_state_client_->async_send_request(request);

    if (rclcpp::spin_until_future_complete(node_, result) !=
      rclcpp::FutureReturnCode::SUCCESS)
    {
      lifecycle_msgs::msg::State get_state;

      RCLCPP_ERROR(node_->get_logger(), "Failed to call get_state service");
      return lifecycle_msgs::msg::State::PRIMARY_STATE_UNKNOWN;
    }

    return result.get()->current_state.id;
  }

  // Get the state of the controlled node. Ot can fail, if not transition possible
  bool set_state(uint8_t state)
  {
    auto request = std::make_shared<lifecycle_msgs::srv::ChangeState::Request>();

    if (state == lifecycle_msgs::msg::State::PRIMARY_STATE_ACTIVE &&
      ctrl_node_state_ == lifecycle_msgs::msg::State::PRIMARY_STATE_INACTIVE)
    {
      request->transition.id = lifecycle_msgs::msg::Transition::TRANSITION_ACTIVATE;
    } else {
      if (state == lifecycle_msgs::msg::State::PRIMARY_STATE_INACTIVE &&
        ctrl_node_state_ == lifecycle_msgs::msg::State::PRIMARY_STATE_ACTIVE)
      {
        request->transition.id = lifecycle_msgs::msg::Transition::TRANSITION_DEACTIVATE;
      } else {
        if (state != ctrl_node_state_) {
          RCLCPP_ERROR(
            node_->get_logger(), "Transition not possible %zu -> %zu", ctrl_node_state_, state);
          return false;
        } else {
          return true;
        }
      }
    }

    auto result = change_state_client_->async_send_request(request);

    if (rclcpp::spin_until_future_complete(node_, result) !=
      rclcpp::FutureReturnCode::SUCCESS)
    {
      RCLCPP_ERROR(node_->get_logger(), "Failed to call set_state service");
      return false;
    }

    if (!result.get()->success) {
      RCLCPP_ERROR(
        node_->get_logger(), "Failed to set node state %zu -> %zu", ctrl_node_state_, state);
      return false;
    } else {
      RCLCPP_INFO(node_->get_logger(), "Transition success  %zu -> %zu", ctrl_node_state_, state);
    }

    ctrl_node_state_ = state;
    return true;
  }

  std::string ctrl_node_name_;
  uint8_t ctrl_node_state_;

  rclcpp::Client<lifecycle_msgs::srv::ChangeState>::SharedPtr change_state_client_;
  rclcpp::Client<lifecycle_msgs::srv::GetState>::SharedPtr get_state_client_;

  rclcpp::Node::SharedPtr node_;
};


}  // namespace br2_bt_patrolling

#endif  // BR2_BT_PATROLLING__CTRL_SUPPORT__BTLIFECYCLECTRLNODE_HPP_
    \end{minted}
    \end{tcolorbox}
  \normalsize

 \footnotesize
\begin{tcolorbox}[sharp corners, colframe=gray!80, colback=LightGray, left=0pt, top=0pt, bottom=0pt, title=\texttt{br2\_bt\_patrolling/include/br2\_bt\_patrolling/ctrl\_support/BTActionNode.hpp}]
  \begin{minted}[
    framesep=2mm,
    baselinestretch=0.8,
    bgcolor=LightGray,
    fontsize=\scriptsize
  ]{CPP}
// Copyright (c) 2018 Intel Corporation
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

#ifndef BR2_BT_PATROLLING__CTRL_SUPPORT__BTACTIONNODE_HPP_
#define BR2_BT_PATROLLING__CTRL_SUPPORT__BTACTIONNODE_HPP_

#include <memory>
#include <string>

#include "behaviortree_cpp_v3/action_node.h"
#include "rclcpp/rclcpp.hpp"
#include "rclcpp_action/rclcpp_action.hpp"

namespace br2_bt_patrolling
{

using namespace std::chrono_literals;  // NOLINT

template<class ActionT, class NodeT = rclcpp::Node>
class BtActionNode : public BT::ActionNodeBase
{
public:
  BtActionNode(
    const std::string & xml_tag_name,
    const std::string & action_name,
    const BT::NodeConfiguration & conf)
  : BT::ActionNodeBase(xml_tag_name, conf), action_name_(action_name)
  {
    node_ = config().blackboard->get<typename NodeT::SharedPtr>("node");

    server_timeout_ = 1s;

    // Initialize the input and output messages
    goal_ = typename ActionT::Goal();
    result_ = typename rclcpp_action::ClientGoalHandle<ActionT>::WrappedResult();

    std::string remapped_action_name;
    if (getInput("server_name", remapped_action_name)) {
      action_name_ = remapped_action_name;
    }
    createActionClient(action_name_);

    // Give the derive class a chance to do any initialization
    RCLCPP_INFO(node_->get_logger(), "\"%s\" BtActionNode initialized", xml_tag_name.c_str());
  }

  BtActionNode() = delete;

  virtual ~BtActionNode()
  {
  }

  // Create instance of an action server
  void createActionClient(const std::string & action_name)
  {
    // Now that we have the ROS node to use, create the action client for this BT action
    action_client_ = rclcpp_action::create_client<ActionT>(node_, action_name);

    // Make sure the server is actually there before continuing
    RCLCPP_INFO(node_->get_logger(), "Waiting for \"%s\" action server", action_name.c_str());
    action_client_->wait_for_action_server();
  }

  // Any subclass of BtActionNode that accepts parameters must provide a providedPorts method
  // and call providedBasicPorts in it.
  static BT::PortsList providedBasicPorts(BT::PortsList addition)
  {
    BT::PortsList basic = {
      BT::InputPort<std::string>("server_name", "Action server name"),
      BT::InputPort<std::chrono::milliseconds>("server_timeout")
    };
    basic.insert(addition.begin(), addition.end());

    return basic;
  }

  static BT::PortsList providedPorts()
  {
    return providedBasicPorts({});
  }

  // Derived classes can override any of the following methods to hook into the
  // processing for the action: on_tick, on_wait_for_result, and on_success

  // Could do dynamic checks, such as getting updates to values on the blackboard
  virtual void on_tick()
  {
  }

  // There can be many loop iterations per tick. Any opportunity to do something after
  // a timeout waiting for a result that hasn't been received yet
  virtual void on_wait_for_result()
  {
  }

  // Called upon successful completion of the action. A derived class can override this
  // method to put a value on the blackboard, for example.
  virtual BT::NodeStatus on_success()
  {
    return BT::NodeStatus::SUCCESS;
  }

  // Called when a the action is aborted. By default, the node will return FAILURE.
  // The user may override it to return another value, instead.
  virtual BT::NodeStatus on_aborted()
  {
    return BT::NodeStatus::FAILURE;
  }

  // Called when a the action is cancelled. By default, the node will return SUCCESS.
  // The user may override it to return another value, instead.
  virtual BT::NodeStatus on_cancelled()
  {
    return BT::NodeStatus::SUCCESS;
  }

  // The main override required by a BT action
  BT::NodeStatus tick() override
  {
    // first step to be done only at the beginning of the Action
    if (status() == BT::NodeStatus::IDLE) {
      createActionClient(action_name_);

      // setting the status to RUNNING to notify the BT Loggers (if any)
      setStatus(BT::NodeStatus::RUNNING);

      // user defined callback
      on_tick();

      on_new_goal_received();
    }

    // The following code corresponds to the "RUNNING" loop
    if (rclcpp::ok() && !goal_result_available_) {
      // user defined callback. May modify the value of "goal_updated_"
      on_wait_for_result();

      auto goal_status = goal_handle_->get_status();
      if (goal_updated_ && (goal_status == action_msgs::msg::GoalStatus::STATUS_EXECUTING ||
        goal_status == action_msgs::msg::GoalStatus::STATUS_ACCEPTED))
      {
        goal_updated_ = false;
        on_new_goal_received();
      }

      rclcpp::spin_some(node_->get_node_base_interface());

      // check if, after invoking spin_some(), we finally received the result
      if (!goal_result_available_) {
        // Yield this Action, returning RUNNING
        return BT::NodeStatus::RUNNING;
      }
    }

    switch (result_.code) {
      case rclcpp_action::ResultCode::SUCCEEDED:
        return on_success();

      case rclcpp_action::ResultCode::ABORTED:
        return on_aborted();

      case rclcpp_action::ResultCode::CANCELED:
        return on_cancelled();

      default:
        throw std::logic_error("BtActionNode::Tick: invalid status value");
    }
  }

  // The other (optional) override required by a BT action. In this case, we
  // make sure to cancel the ROS2 action if it is still running.
  void halt() override
  {
    if (should_cancel_goal()) {
      auto future_cancel = action_client_->async_cancel_goal(goal_handle_);
      if (rclcpp::spin_until_future_complete(
          node_->get_node_base_interface(), future_cancel, server_timeout_) !=
        rclcpp::FutureReturnCode::SUCCESS)
      {
        RCLCPP_ERROR(
          node_->get_logger(),
          "Failed to cancel action server for %s", action_name_.c_str());
      }
    }

    setStatus(BT::NodeStatus::IDLE);
  }

protected:
  bool should_cancel_goal()
  {
    // Shut the node down if it is currently running
    if (status() != BT::NodeStatus::RUNNING) {
      return false;
    }

    rclcpp::spin_some(node_->get_node_base_interface());
    auto status = goal_handle_->get_status();

    // Check if the goal is still executing
    return status == action_msgs::msg::GoalStatus::STATUS_ACCEPTED ||
           status == action_msgs::msg::GoalStatus::STATUS_EXECUTING;
  }


  void on_new_goal_received()
  {
    goal_result_available_ = false;
    auto send_goal_options = typename rclcpp_action::Client<ActionT>::SendGoalOptions();
    send_goal_options.result_callback =
      [this](const typename rclcpp_action::ClientGoalHandle<ActionT>::WrappedResult & result) {
        // TODO(#1652): a work around until rcl_action interface is updated
        // if goal ids are not matched, the older goal call this callback so ignore the result
        // if matched, it must be processed (including aborted)
        if (this->goal_handle_->get_goal_id() == result.goal_id) {
          goal_result_available_ = true;
          result_ = result;
        }
      };

    auto future_goal_handle = action_client_->async_send_goal(goal_, send_goal_options);

    if (rclcpp::spin_until_future_complete(
        node_->get_node_base_interface(), future_goal_handle, server_timeout_) !=
      rclcpp::FutureReturnCode::SUCCESS)
    {
      throw std::runtime_error("send_goal failed");
    }

    goal_handle_ = future_goal_handle.get();
    if (!goal_handle_) {
      throw std::runtime_error("Goal was rejected by the action server");
    }
  }

  void increment_recovery_count()
  {
    int recovery_count = 0;
    config().blackboard->get<int>("number_recoveries", recovery_count);  // NOLINT
    recovery_count += 1;
    config().blackboard->set<int>("number_recoveries", recovery_count);  // NOLINT
  }

  std::string action_name_;
  typename std::shared_ptr<rclcpp_action::Client<ActionT>> action_client_;

  // All ROS2 actions have a goal and a result
  typename ActionT::Goal goal_;
  bool goal_updated_{false};
  bool goal_result_available_{false};
  typename rclcpp_action::ClientGoalHandle<ActionT>::SharedPtr goal_handle_;
  typename rclcpp_action::ClientGoalHandle<ActionT>::WrappedResult result_;

  // The node that will be used for any ROS operations
  typename NodeT::SharedPtr node_;

  // The timeout value while waiting for response from a server when a
  // new action goal is sent or canceled
  std::chrono::milliseconds server_timeout_;
};


}  // namespace br2_bt_patrolling

#endif  // BR2_BT_PATROLLING__CTRL_SUPPORT__BTACTIONNODE_HPP_
    \end{minted}
    \end{tcolorbox}
  \normalsize

 \footnotesize
\begin{tcolorbox}[sharp corners, colframe=gray!80, colback=LightGray, left=0pt, top=0pt, bottom=0pt, title=\texttt{br2\_bt\_patrolling/include/br2\_bt\_patrolling/Recharge.hpp}]
  \begin{minted}[
    framesep=2mm,
    baselinestretch=0.8,
    bgcolor=LightGray,
    fontsize=\scriptsize
  ]{CPP}
// Copyright 2021 Intelligent Robotics Lab
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

#ifndef BR2_BT_PATROLLING__RECHARGE_HPP_
#define BR2_BT_PATROLLING__RECHARGE_HPP_

#include <string>

#include "behaviortree_cpp_v3/behavior_tree.h"
#include "behaviortree_cpp_v3/bt_factory.h"

namespace br2_bt_patrolling
{

class Recharge : public BT::ActionNodeBase
{
public:
  explicit Recharge(
    const std::string & xml_tag_name,
    const BT::NodeConfiguration & conf);

  void halt();
  BT::NodeStatus tick();

  static BT::PortsList providedPorts()
  {
    return BT::PortsList({});
  }

private:
  int counter_;
};

}  // namespace br2_bt_patrolling

#endif  // BR2_BT_PATROLLING__RECHARGE_HPP_
    \end{minted}
    \end{tcolorbox}
  \normalsize

 \footnotesize
\begin{tcolorbox}[sharp corners, colframe=gray!80, colback=LightGray, left=0pt, top=0pt, bottom=0pt, title=\texttt{br2\_bt\_patrolling/include/br2\_bt\_patrolling/GetWaypoint.hpp}]
  \begin{minted}[
    framesep=2mm,
    baselinestretch=0.8,
    bgcolor=LightGray,
    fontsize=\scriptsize
  ]{CPP}
// Copyright 2021 Intelligent Robotics Lab
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

#ifndef BR2_BT_PATROLLING__GETWAYPOINT_HPP_
#define BR2_BT_PATROLLING__GETWAYPOINT_HPP_

#include <string>
#include <vector>

#include "behaviortree_cpp_v3/behavior_tree.h"
#include "behaviortree_cpp_v3/bt_factory.h"

#include "geometry_msgs/msg/pose_stamped.hpp"

namespace br2_bt_patrolling
{

class GetWaypoint : public BT::ActionNodeBase
{
public:
  explicit GetWaypoint(
    const std::string & xml_tag_name,
    const BT::NodeConfiguration & conf);

  void halt();
  BT::NodeStatus tick();

  static BT::PortsList providedPorts()
  {
    return BT::PortsList(
      {
        BT::InputPort<std::string>("wp_id"),
        BT::OutputPort<geometry_msgs::msg::PoseStamped>("waypoint")
      });
  }

private:
  geometry_msgs::msg::PoseStamped recharge_point_;
  std::vector<geometry_msgs::msg::PoseStamped> waypoints_;
  static int current_;
};

}  // namespace br2_bt_patrolling

#endif  // BR2_BT_PATROLLING__GETWAYPOINT_HPP_
    \end{minted}
    \end{tcolorbox}
  \normalsize

 \footnotesize
\begin{tcolorbox}[sharp corners, colframe=gray!80, colback=LightGray, left=0pt, top=0pt, bottom=0pt, title=\texttt{br2\_bt\_patrolling/include/br2\_bt\_patrolling/Patrol.hpp}]
  \begin{minted}[
    framesep=2mm,
    baselinestretch=0.8,
    bgcolor=LightGray,
    fontsize=\scriptsize
  ]{CPP}
// Copyright 2021 Intelligent Robotics Lab
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

#ifndef BR2_BT_PATROLLING__PATROL_HPP_
#define BR2_BT_PATROLLING__PATROL_HPP_

#include <string>

#include "behaviortree_cpp_v3/behavior_tree.h"
#include "behaviortree_cpp_v3/bt_factory.h"

#include "geometry_msgs/msg/twist.hpp"

#include "rclcpp/rclcpp.hpp"

namespace br2_bt_patrolling
{

class Patrol : public BT::ActionNodeBase
{
public:
  explicit Patrol(
    const std::string & xml_tag_name,
    const BT::NodeConfiguration & conf);

  void halt();
  BT::NodeStatus tick();

  static BT::PortsList providedPorts()
  {
    return BT::PortsList({});
  }

private:
  rclcpp::Node::SharedPtr node_;
  rclcpp::Time start_time_;
  rclcpp::Publisher<geometry_msgs::msg::Twist>::SharedPtr vel_pub_;
};

}  // namespace br2_bt_patrolling

#endif  // BR2_BT_PATROLLING__PATROL_HPP_
    \end{minted}
    \end{tcolorbox}
  \normalsize

 \footnotesize
\begin{tcolorbox}[sharp corners, colframe=gray!80, colback=LightGray, left=0pt, top=0pt, bottom=0pt, title=\texttt{br2\_bt\_patrolling/include/br2\_bt\_patrolling/TrackObjects.hpp}]
  \begin{minted}[
    framesep=2mm,
    baselinestretch=0.8,
    bgcolor=LightGray,
    fontsize=\scriptsize
  ]{CPP}
// Copyright 2021 Intelligent Robotics Lab
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

#ifndef BR2_BT_PATROLLING__TRACKOBJECTS_HPP_
#define BR2_BT_PATROLLING__TRACKOBJECTS_HPP_

#include <string>

#include "geometry_msgs/msg/pose_stamped.hpp"
#include "nav2_msgs/action/navigate_to_pose.hpp"

#include "br2_bt_patrolling/ctrl_support/BTLifecycleCtrlNode.hpp"
#include "behaviortree_cpp_v3/behavior_tree.h"
#include "behaviortree_cpp_v3/bt_factory.h"

namespace br2_bt_patrolling
{

class TrackObjects : public br2_bt_patrolling::BtLifecycleCtrlNode
{
public:
  explicit TrackObjects(
    const std::string & xml_tag_name,
    const std::string & node_name,
    const BT::NodeConfiguration & conf);

  static BT::PortsList providedPorts()
  {
    return BT::PortsList({});
  }
};

}  // namespace br2_bt_patrolling

#endif  // BR2_BT_PATROLLING__TRACKOBJECTS_HPP_
    \end{minted}
    \end{tcolorbox}
  \normalsize

 \footnotesize
\begin{tcolorbox}[sharp corners, colframe=gray!80, colback=LightGray, left=0pt, top=0pt, bottom=0pt, title=\texttt{br2\_bt\_patrolling/include/br2\_bt\_patrolling/Move.hpp}]
  \begin{minted}[
    framesep=2mm,
    baselinestretch=0.8,
    bgcolor=LightGray,
    fontsize=\scriptsize
  ]{CPP}
// Copyright 2021 Intelligent Robotics Lab
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

#ifndef BR2_BT_PATROLLING__MOVE_HPP_
#define BR2_BT_PATROLLING__MOVE_HPP_

#include <string>

#include "geometry_msgs/msg/pose_stamped.hpp"
#include "nav2_msgs/action/navigate_to_pose.hpp"

#include "br2_bt_patrolling/ctrl_support/BTActionNode.hpp"
#include "behaviortree_cpp_v3/behavior_tree.h"
#include "behaviortree_cpp_v3/bt_factory.h"

namespace br2_bt_patrolling
{

class Move : public br2_bt_patrolling::BtActionNode<nav2_msgs::action::NavigateToPose>
{
public:
  explicit Move(
    const std::string & xml_tag_name,
    const std::string & action_name,
    const BT::NodeConfiguration & conf);

  void on_tick() override;
  BT::NodeStatus on_success() override;

  static BT::PortsList providedPorts()
  {
    return {
      BT::InputPort<geometry_msgs::msg::PoseStamped>("goal")
    };
  }
};

}  // namespace br2_bt_patrolling

#endif  // BR2_BT_PATROLLING__MOVE_HPP_
    \end{minted}
    \end{tcolorbox}
  \normalsize

 \footnotesize
\begin{tcolorbox}[sharp corners, colframe=gray!80, colback=LightGray, left=0pt, top=0pt, bottom=0pt, title=\texttt{br2\_bt\_patrolling/src/br2\_bt\_patrolling/Patrol.cpp}]
  \begin{minted}[
    framesep=2mm,
    baselinestretch=0.8,
    bgcolor=LightGray,
    fontsize=\scriptsize
  ]{CPP}
// Copyright 2021 Intelligent Robotics Lab
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

#include <string>
#include <iostream>

#include "br2_bt_patrolling/Patrol.hpp"

#include "behaviortree_cpp_v3/behavior_tree.h"

#include "geometry_msgs/msg/twist.hpp"

#include "rclcpp/rclcpp.hpp"

namespace br2_bt_patrolling
{

using namespace std::chrono_literals;

Patrol::Patrol(
  const std::string & xml_tag_name,
  const BT::NodeConfiguration & conf)
: BT::ActionNodeBase(xml_tag_name, conf)
{
  config().blackboard->get("node", node_);

  vel_pub_ = node_->create_publisher<geometry_msgs::msg::Twist>("/output_vel", 100);
}

void
Patrol::halt()
{
  std::cout << "Patrol halt" << std::endl;
}

BT::NodeStatus
Patrol::tick()
{
  if (status() == BT::NodeStatus::IDLE) {
    start_time_ = node_->now();
  }

  geometry_msgs::msg::Twist vel_msgs;
  vel_msgs.angular.z = 0.5;
  vel_pub_->publish(vel_msgs);

  auto elapsed = node_->now() - start_time_;

  if (elapsed < 15s) {
    return BT::NodeStatus::RUNNING;
  } else {
    return BT::NodeStatus::SUCCESS;
  }
}

}  // namespace br2_bt_patrolling

#include "behaviortree_cpp_v3/bt_factory.h"
BT_REGISTER_NODES(factory)
{
  factory.registerNodeType<br2_bt_patrolling::Patrol>("Patrol");
}
    \end{minted}
    \end{tcolorbox}
  \normalsize

 \footnotesize
\begin{tcolorbox}[sharp corners, colframe=gray!80, colback=LightGray, left=0pt, top=0pt, bottom=0pt, title=\texttt{br2\_bt\_patrolling/src/br2\_bt\_patrolling/Recharge.cpp}]
  \begin{minted}[
    framesep=2mm,
    baselinestretch=0.8,
    bgcolor=LightGray,
    fontsize=\scriptsize
  ]{CPP}
// Copyright 2021 Intelligent Robotics Lab
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

#include <string>
#include <iostream>
#include <set>

#include "br2_bt_patrolling/Recharge.hpp"

#include "behaviortree_cpp_v3/behavior_tree.h"

namespace br2_bt_patrolling
{

Recharge::Recharge(
  const std::string & xml_tag_name,
  const BT::NodeConfiguration & conf)
: BT::ActionNodeBase(xml_tag_name, conf), counter_(0)
{
}

void
Recharge::halt()
{
}

BT::NodeStatus
Recharge::tick()
{
  std::cout << "Recharge tick " << counter_ << std::endl;

  if (counter_++ < 50) {
    return BT::NodeStatus::RUNNING;
  } else {
    counter_ = 0;
    config().blackboard->set<float>("battery_level", 100.0f);
    return BT::NodeStatus::SUCCESS;
  }
}

}  // namespace br2_bt_patrolling

#include "behaviortree_cpp_v3/bt_factory.h"
BT_REGISTER_NODES(factory)
{
  factory.registerNodeType<br2_bt_patrolling::Recharge>("Recharge");
}
    \end{minted}
    \end{tcolorbox}
  \normalsize

 \footnotesize
\begin{tcolorbox}[sharp corners, colframe=gray!80, colback=LightGray, left=0pt, top=0pt, bottom=0pt, title=\texttt{br2\_bt\_patrolling/src/br2\_bt\_patrolling/GetWaypoint.cpp}]
  \begin{minted}[
    framesep=2mm,
    baselinestretch=0.8,
    bgcolor=LightGray,
    fontsize=\scriptsize
  ]{CPP}
// Copyright 2021 Intelligent Robotics Lab
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

#include <string>
#include <iostream>
#include <vector>

#include "br2_bt_patrolling/GetWaypoint.hpp"

#include "behaviortree_cpp_v3/behavior_tree.h"

#include "geometry_msgs/msg/pose_stamped.hpp"

#include "rclcpp/rclcpp.hpp"

namespace br2_bt_patrolling
{

int GetWaypoint::current_ = 0;

GetWaypoint::GetWaypoint(
  const std::string & xml_tag_name,
  const BT::NodeConfiguration & conf)
: BT::ActionNodeBase(xml_tag_name, conf)
{
  rclcpp::Node::SharedPtr node;
  config().blackboard->get("node", node);

  geometry_msgs::msg::PoseStamped wp;
  wp.header.frame_id = "map";
  wp.pose.orientation.w = 1.0;

  // recharge wp
  wp.pose.position.x = 3.67;
  wp.pose.position.y = -0.24;
  recharge_point_ = wp;

  // wp1
  wp.pose.position.x = 1.07;
  wp.pose.position.y = -12.38;
  waypoints_.push_back(wp);

  // wp2
  wp.pose.position.x = -5.32;
  wp.pose.position.y = -8.85;
  waypoints_.push_back(wp);

  // wp3
  wp.pose.position.x = -0.56;
  wp.pose.position.y = 0.24;
  waypoints_.push_back(wp);
}

void
GetWaypoint::halt()
{
}

BT::NodeStatus
GetWaypoint::tick()
{
  std::string id;
  getInput("wp_id", id);

  if (id == "recharge") {
    setOutput("waypoint", recharge_point_);
  } else {
    setOutput("waypoint", waypoints_[current_++]);
    current_ = current_ % waypoints_.size();
  }

  return BT::NodeStatus::SUCCESS;
}

}  // namespace br2_bt_patrolling

#include "behaviortree_cpp_v3/bt_factory.h"
BT_REGISTER_NODES(factory)
{
  factory.registerNodeType<br2_bt_patrolling::GetWaypoint>("GetWaypoint");
}
    \end{minted}
    \end{tcolorbox}
  \normalsize

 \footnotesize
\begin{tcolorbox}[sharp corners, colframe=gray!80, colback=LightGray, left=0pt, top=0pt, bottom=0pt, title=\texttt{br2\_bt\_patrolling/src/br2\_bt\_patrolling/Move.cpp}]
  \begin{minted}[
    framesep=2mm,
    baselinestretch=0.8,
    bgcolor=LightGray,
    fontsize=\scriptsize
  ]{CPP}
// Copyright 2019 Intelligent Robotics Lab
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

#include <string>
#include <iostream>
#include <vector>
#include <memory>

#include "br2_bt_patrolling/Move.hpp"

#include "geometry_msgs/msg/pose_stamped.hpp"
#include "nav2_msgs/action/navigate_to_pose.hpp"

#include "behaviortree_cpp_v3/behavior_tree.h"

namespace br2_bt_patrolling
{

Move::Move(
  const std::string & xml_tag_name,
  const std::string & action_name,
  const BT::NodeConfiguration & conf)
: br2_bt_patrolling::BtActionNode<nav2_msgs::action::NavigateToPose>(xml_tag_name, action_name,
    conf)
{
}

void
Move::on_tick()
{
  geometry_msgs::msg::PoseStamped goal;
  getInput("goal", goal);

  goal_.pose = goal;
}

BT::NodeStatus
Move::on_success()
{
  RCLCPP_INFO(node_->get_logger(), "navigation Suceeded");

  return BT::NodeStatus::SUCCESS;
}


}  // namespace br2_bt_patrolling

#include "behaviortree_cpp_v3/bt_factory.h"
BT_REGISTER_NODES(factory)
{
  BT::NodeBuilder builder =
    [](const std::string & name, const BT::NodeConfiguration & config)
    {
      return std::make_unique<br2_bt_patrolling::Move>(
        name, "navigate_to_pose", config);
    };

  factory.registerBuilder<br2_bt_patrolling::Move>(
    "Move", builder);
}
    \end{minted}
    \end{tcolorbox}
  \normalsize

 \footnotesize
\begin{tcolorbox}[sharp corners, colframe=gray!80, colback=LightGray, left=0pt, top=0pt, bottom=0pt, title=\texttt{br2\_bt\_patrolling/src/br2\_bt\_patrolling/BatteryChecker.cpp}]
  \begin{minted}[
    framesep=2mm,
    baselinestretch=0.8,
    bgcolor=LightGray,
    fontsize=\scriptsize
  ]{CPP}
// Copyright 2021 Intelligent Robotics Lab
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

#include <string>
#include <iostream>
#include <algorithm>

#include "br2_bt_patrolling/BatteryChecker.hpp"

#include "behaviortree_cpp_v3/behavior_tree.h"

#include "geometry_msgs/msg/twist.hpp"

#include "rclcpp/rclcpp.hpp"

namespace br2_bt_patrolling
{

using namespace std::chrono_literals;
using namespace std::placeholders;

BatteryChecker::BatteryChecker(
  const std::string & xml_tag_name,
  const BT::NodeConfiguration & conf)
: BT::ConditionNode(xml_tag_name, conf)
{
  config().blackboard->get("node", node_);

  vel_sub_ = node_->create_subscription<geometry_msgs::msg::Twist>(
    "/output_vel", 100, std::bind(&BatteryChecker::vel_callback, this, _1));

  last_reading_time_ = node_->now();
}

void
BatteryChecker::vel_callback(const geometry_msgs::msg::Twist::SharedPtr msg)
{
  last_twist_ = *msg;
}

void
BatteryChecker::update_battery()
{
  float battery_level;
  if (!config().blackboard->get("battery_level", battery_level)) {
    battery_level = 100.0f;
  }

  float dt = (node_->now() - last_reading_time_).seconds();
  last_reading_time_ = node_->now();

  float vel = sqrt(last_twist_.linear.x * last_twist_.linear.x +
    last_twist_.angular.z * last_twist_.angular.z);
  battery_level = std::max(0.0f, battery_level -(vel * dt * DECAY_LEVEL) - EPSILON * dt);

  config().blackboard->set("battery_level", battery_level);
}

BT::NodeStatus
BatteryChecker::tick()
{
  update_battery();

  float battery_level;
  config().blackboard->get("battery_level", battery_level);

  std::cout << battery_level << std::endl;

  if (battery_level < MIN_LEVEL) {
    return BT::NodeStatus::FAILURE;
  } else {
    return BT::NodeStatus::SUCCESS;
  }
}

}  // namespace br2_bt_patrolling

#include "behaviortree_cpp_v3/bt_factory.h"
BT_REGISTER_NODES(factory)
{
  factory.registerNodeType<br2_bt_patrolling::BatteryChecker>("BatteryChecker");
}
    \end{minted}
    \end{tcolorbox}
  \normalsize

 \footnotesize
\begin{tcolorbox}[sharp corners, colframe=gray!80, colback=LightGray, left=0pt, top=0pt, bottom=0pt, title=\texttt{br2\_bt\_patrolling/src/br2\_bt\_patrolling/TrackObjects.cpp}]
  \begin{minted}[
    framesep=2mm,
    baselinestretch=0.8,
    bgcolor=LightGray,
    fontsize=\scriptsize
  ]{CPP}
// Copyright 2019 Intelligent Robotics Lab
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

#include <string>
#include <iostream>
#include <vector>
#include <memory>

#include "br2_bt_patrolling/TrackObjects.hpp"

#include "geometry_msgs/msg/pose_stamped.hpp"
#include "nav2_msgs/action/navigate_to_pose.hpp"

#include "behaviortree_cpp_v3/behavior_tree.h"

namespace br2_bt_patrolling
{

TrackObjects::TrackObjects(
  const std::string & xml_tag_name,
  const std::string & action_name,
  const BT::NodeConfiguration & conf)
: br2_bt_patrolling::BtLifecycleCtrlNode(xml_tag_name, action_name, conf)
{
}

}  // namespace br2_bt_patrolling

#include "behaviortree_cpp_v3/bt_factory.h"
BT_REGISTER_NODES(factory)
{
  BT::NodeBuilder builder =
    [](const std::string & name, const BT::NodeConfiguration & config)
    {
      return std::make_unique<br2_bt_patrolling::TrackObjects>(
        name, "/head_tracker", config);
    };

  factory.registerBuilder<br2_bt_patrolling::TrackObjects>(
    "TrackObjects", builder);
}
    \end{minted}
    \end{tcolorbox}
  \normalsize

 \footnotesize
\begin{tcolorbox}[sharp corners, colframe=gray!80, colback=LightGray, left=0pt, top=0pt, bottom=0pt, title=\texttt{br2\_bt\_patrolling/src/patrolling\_main.cpp}]
  \begin{minted}[
    framesep=2mm,
    baselinestretch=0.8,
    bgcolor=LightGray,
    fontsize=\scriptsize
  ]{CPP}
// Copyright 2021 Intelligent Robotics Lab
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

#include <string>
#include <memory>

#include "behaviortree_cpp_v3/behavior_tree.h"
#include "behaviortree_cpp_v3/bt_factory.h"
#include "behaviortree_cpp_v3/utils/shared_library.h"
#include "behaviortree_cpp_v3/loggers/bt_zmq_publisher.h"

#include "ament_index_cpp/get_package_share_directory.hpp"

#include "rclcpp/rclcpp.hpp"


int main(int argc, char * argv[])
{
  rclcpp::init(argc, argv);

  auto node = rclcpp::Node::make_shared("patrolling_node");

  BT::BehaviorTreeFactory factory;
  BT::SharedLibrary loader;

  factory.registerFromPlugin(loader.getOSName("br2_battery_checker_bt_node"));
  factory.registerFromPlugin(loader.getOSName("br2_patrol_bt_node"));
  factory.registerFromPlugin(loader.getOSName("br2_recharge_bt_node"));
  factory.registerFromPlugin(loader.getOSName("br2_move_bt_node"));
  factory.registerFromPlugin(loader.getOSName("br2_get_waypoint_bt_node"));
  factory.registerFromPlugin(loader.getOSName("br2_track_objects_bt_node"));

  std::string pkgpath = ament_index_cpp::get_package_share_directory("br2_bt_patrolling");
  std::string xml_file = pkgpath + "/behavior_tree_xml/patrolling.xml";

  auto blackboard = BT::Blackboard::create();
  blackboard->set("node", node);
  BT::Tree tree = factory.createTreeFromFile(xml_file, blackboard);

  auto publisher_zmq = std::make_shared<BT::PublisherZMQ>(tree, 10, 2666, 2667);

  rclcpp::Rate rate(10);

  bool finish = false;
  while (!finish && rclcpp::ok()) {
    finish = tree.rootNode()->executeTick() == BT::NodeStatus::SUCCESS;

    rclcpp::spin_some(node);
    rate.sleep();
  }

  rclcpp::shutdown();
  return 0;
}
    \end{minted}
    \end{tcolorbox}
  \normalsize

 \footnotesize
\begin{tcolorbox}[sharp corners, colframe=gray!80, colback=LightGray, left=0pt, top=0pt, bottom=0pt, title=\texttt{br2\_bt\_patrolling/tests/bt\_action\_test.cpp}]
  \begin{minted}[
    framesep=2mm,
    baselinestretch=0.8,
    bgcolor=LightGray,
    fontsize=\scriptsize
  ]{CPP}
// Copyright 2021 Intelligent Robotics Lab
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

#include <string>
#include <list>
#include <memory>
#include <vector>
#include <set>

#include "behaviortree_cpp_v3/behavior_tree.h"
#include "behaviortree_cpp_v3/bt_factory.h"
#include "behaviortree_cpp_v3/utils/shared_library.h"

#include "ament_index_cpp/get_package_share_directory.hpp"

#include "geometry_msgs/msg/twist.hpp"
#include "nav2_msgs/action/navigate_to_pose.hpp"
#include "lifecycle_msgs/msg/transition.hpp"
#include "lifecycle_msgs/msg/state.hpp"

#include "rclcpp/rclcpp.hpp"
#include "rclcpp_lifecycle/lifecycle_node.hpp"
#include "rclcpp_action/rclcpp_action.hpp"

#include "br2_bt_patrolling/TrackObjects.hpp"

#include "gtest/gtest.h"

using namespace std::placeholders;
using namespace std::chrono_literals;


class VelocitySinkNode : public rclcpp::Node
{
public:
  VelocitySinkNode()
  : Node("VelocitySink")
  {
    vel_sub_ = create_subscription<geometry_msgs::msg::Twist>(
      "/output_vel", 100, std::bind(&VelocitySinkNode::vel_callback, this, _1));
  }

  void vel_callback(geometry_msgs::msg::Twist::SharedPtr msg)
  {
    vel_msgs_.push_back(*msg);
  }

  std::list<geometry_msgs::msg::Twist> vel_msgs_;

private:
  rclcpp::Subscription<geometry_msgs::msg::Twist>::SharedPtr vel_sub_;
};

class Nav2FakeServer : public rclcpp::Node
{
  using NavigateToPose = nav2_msgs::action::NavigateToPose;
  using GoalHandleNavigateToPose = rclcpp_action::ServerGoalHandle<NavigateToPose>;

public:
  Nav2FakeServer()
  : Node("nav2_fake_server_node") {}

  void start_server()
  {
    move_action_server_ = rclcpp_action::create_server<NavigateToPose>(
      shared_from_this(),
      "navigate_to_pose",
      std::bind(&Nav2FakeServer::handle_goal, this, _1, _2),
      std::bind(&Nav2FakeServer::handle_cancel, this, _1),
      std::bind(&Nav2FakeServer::handle_accepted, this, _1));
  }

private:
  rclcpp_action::Server<NavigateToPose>::SharedPtr move_action_server_;

  rclcpp_action::GoalResponse handle_goal(
    const rclcpp_action::GoalUUID & uuid,
    std::shared_ptr<const NavigateToPose::Goal> goal)
  {
    return rclcpp_action::GoalResponse::ACCEPT_AND_EXECUTE;
  }

  rclcpp_action::CancelResponse handle_cancel(
    const std::shared_ptr<GoalHandleNavigateToPose> goal_handle)
  {
    return rclcpp_action::CancelResponse::ACCEPT;
  }

  void handle_accepted(const std::shared_ptr<GoalHandleNavigateToPose> goal_handle)
  {
    std::thread{std::bind(&Nav2FakeServer::execute, this, _1), goal_handle}.detach();
  }

  void execute(const std::shared_ptr<GoalHandleNavigateToPose> goal_handle)
  {
    auto feedback = std::make_shared<NavigateToPose::Feedback>();
    auto result = std::make_shared<NavigateToPose::Result>();

    auto start = now();

    while ((now() - start) < 5s) {
      feedback->distance_remaining = 5.0 - (now() - start).seconds();
      goal_handle->publish_feedback(feedback);
    }

    goal_handle->succeed(result);
  }
};

class StoreWP : public BT::ActionNodeBase
{
public:
  explicit StoreWP(
    const std::string & xml_tag_name,
    const BT::NodeConfiguration & conf)
  : BT::ActionNodeBase(xml_tag_name, conf) {}

  void halt() {}
  BT::NodeStatus tick()
  {
    waypoints_.push_back(getInput<geometry_msgs::msg::PoseStamped>("in").value());
    return BT::NodeStatus::SUCCESS;
  }

  static BT::PortsList providedPorts()
  {
    return BT::PortsList(
    {
      BT::InputPort<geometry_msgs::msg::PoseStamped>("in")
    });
  }

  static std::vector<geometry_msgs::msg::PoseStamped> waypoints_;
};

std::vector<geometry_msgs::msg::PoseStamped> StoreWP::waypoints_;

TEST(bt_action, recharge_btn)
{
  auto node = rclcpp::Node::make_shared("recharge_btn_node");

  BT::BehaviorTreeFactory factory;
  BT::SharedLibrary loader;

  factory.registerFromPlugin(loader.getOSName("br2_recharge_bt_node"));

  std::string xml_bt =
    R"(
    <root main_tree_to_execute = "MainTree" >
      <BehaviorTree ID="MainTree">
          <Recharge    name="recharge"/>
      </BehaviorTree>
    </root>)";

  auto blackboard = BT::Blackboard::create();
  blackboard->set("node", node);
  BT::Tree tree = factory.createTreeFromText(xml_bt, blackboard);

  rclcpp::Rate rate(10);

  bool finish = false;
  while (!finish && rclcpp::ok()) {
    finish = tree.rootNode()->executeTick() == BT::NodeStatus::SUCCESS;
    rate.sleep();
  }

  float battery_level;
  ASSERT_TRUE(blackboard->get("battery_level", battery_level));
  ASSERT_NEAR(battery_level, 100.0f, 0.0000001);
}

TEST(bt_action, patrol_btn)
{
  auto node = rclcpp::Node::make_shared("patrol_btn_node");
  auto node_sink = std::make_shared<VelocitySinkNode>();

  BT::BehaviorTreeFactory factory;
  BT::SharedLibrary loader;

  factory.registerFromPlugin(loader.getOSName("br2_patrol_bt_node"));

  std::string xml_bt =
    R"(
    <root main_tree_to_execute = "MainTree" >
      <BehaviorTree ID="MainTree">
          <Patrol    name="patrol"/>
      </BehaviorTree>
    </root>)";

  auto blackboard = BT::Blackboard::create();
  blackboard->set("node", node);
  BT::Tree tree = factory.createTreeFromText(xml_bt, blackboard);

  rclcpp::Rate rate(10);

  bool finish = false;
  int counter = 0;
  while (!finish && rclcpp::ok()) {
    finish = tree.rootNode()->executeTick() == BT::NodeStatus::SUCCESS;
    rclcpp::spin_some(node_sink->get_node_base_interface());
    rate.sleep();
  }

  ASSERT_FALSE(node_sink->vel_msgs_.empty());
  ASSERT_NEAR(node_sink->vel_msgs_.size(), 150, 2);

  geometry_msgs::msg::Twist & one_twist = node_sink->vel_msgs_.front();

  ASSERT_GT(one_twist.angular.z, 0.1);
  ASSERT_NEAR(one_twist.linear.x, 0.0, 0.0000001);
}

TEST(bt_action, move_btn)
{
  auto node = rclcpp::Node::make_shared("move_btn_node");
  auto nav2_fake_node = std::make_shared<Nav2FakeServer>();

  nav2_fake_node->start_server();

  bool finish = false;
  std::thread t([&]() {
      while (!finish) {rclcpp::spin_some(nav2_fake_node);}
    });


  BT::BehaviorTreeFactory factory;
  BT::SharedLibrary loader;

  factory.registerFromPlugin(loader.getOSName("br2_move_bt_node"));

  std::string xml_bt =
    R"(
    <root main_tree_to_execute = "MainTree" >
      <BehaviorTree ID="MainTree">
          <Move    name="move" goal="{goal}"/>
      </BehaviorTree>
    </root>)";

  auto blackboard = BT::Blackboard::create();
  blackboard->set("node", node);

  geometry_msgs::msg::PoseStamped goal;
  blackboard->set("goal", goal);

  BT::Tree tree = factory.createTreeFromText(xml_bt, blackboard);

  rclcpp::Rate rate(10);

  int counter = 0;
  while (!finish && rclcpp::ok()) {
    finish = tree.rootNode()->executeTick() == BT::NodeStatus::SUCCESS;
    rate.sleep();
  }

  t.join();
}

TEST(bt_action, get_waypoint_btn)
{
  auto node = rclcpp::Node::make_shared("get_waypoint_btn_node");

  rclcpp::spin_some(node);

  {
    BT::BehaviorTreeFactory factory;
    BT::SharedLibrary loader;

    factory.registerFromPlugin(loader.getOSName("br2_get_waypoint_bt_node"));

    std::string xml_bt =
      R"(
      <root main_tree_to_execute = "MainTree" >
        <BehaviorTree ID="MainTree">
          <GetWaypoint    name="recharge" wp_id="{id}" waypoint="{waypoint}"/>
        </BehaviorTree>
      </root>)";

    auto blackboard = BT::Blackboard::create();
    blackboard->set("node", node);
    blackboard->set<std::string>("id", "recharge");

    BT::Tree tree = factory.createTreeFromText(xml_bt, blackboard);

    rclcpp::Rate rate(10);

    bool finish = false;
    int counter = 0;
    while (!finish && rclcpp::ok()) {
      finish = tree.rootNode()->executeTick() == BT::NodeStatus::SUCCESS;
      counter++;
      rate.sleep();
    }

    auto point = blackboard->get<geometry_msgs::msg::PoseStamped>("waypoint");

    ASSERT_EQ(counter, 1);
    ASSERT_NEAR(point.pose.position.x, 3.67, 0.0000001);
    ASSERT_NEAR(point.pose.position.y, -0.24, 0.0000001);
  }

  {
    BT::BehaviorTreeFactory factory;
    BT::SharedLibrary loader;

    factory.registerNodeType<StoreWP>("StoreWP");
    factory.registerFromPlugin(loader.getOSName("br2_get_waypoint_bt_node"));

    std::string xml_bt =
      R"(
      <root main_tree_to_execute = "MainTree" >
        <BehaviorTree ID="MainTree">
          <Sequence name="root_sequence">
             <GetWaypoint    name="wp1" wp_id="next" waypoint="{waypoint}"/>
             <StoreWP in="{waypoint}"/>
             <GetWaypoint    name="wp2" wp_id="next" waypoint="{waypoint}"/>
             <StoreWP in="{waypoint}"/>
             <GetWaypoint    name="wp3" wp_id="" waypoint="{waypoint}"/>
             <StoreWP in="{waypoint}"/>
             <GetWaypoint    name="wp4" wp_id="recharge" waypoint="{waypoint}"/>
             <StoreWP in="{waypoint}"/>
             <GetWaypoint    name="wp5" wp_id="wp1" waypoint="{waypoint}"/>
             <StoreWP in="{waypoint}"/>
             <GetWaypoint    name="wp6" wp_id="wp2" waypoint="{waypoint}"/>
             <StoreWP in="{waypoint}"/>
             <GetWaypoint    name="wpt" waypoint="{waypoint}"/>
             <StoreWP in="{waypoint}"/>
          </Sequence>
        </BehaviorTree>
      </root>)";

    auto blackboard = BT::Blackboard::create();
    blackboard->set("node", node);

    BT::Tree tree = factory.createTreeFromText(xml_bt, blackboard);

    rclcpp::Rate rate(10);

    bool finish = false;
    while (!finish && rclcpp::ok()) {
      finish = tree.rootNode()->executeTick() == BT::NodeStatus::SUCCESS;
      rate.sleep();
    }

    const auto & waypoints = StoreWP::waypoints_;
    ASSERT_EQ(waypoints.size(), 7);
    ASSERT_NEAR(waypoints[0].pose.position.x, 1.07, 0.0000001);
    ASSERT_NEAR(waypoints[0].pose.position.y, -12.38, 0.0000001);
    ASSERT_NEAR(waypoints[1].pose.position.x, -5.32, 0.0000001);
    ASSERT_NEAR(waypoints[1].pose.position.y, -8.85, 0.0000001);
    ASSERT_NEAR(waypoints[2].pose.position.x, -0.56, 0.0000001);
    ASSERT_NEAR(waypoints[2].pose.position.y, 0.24, 0.0000001);

    ASSERT_NEAR(waypoints[3].pose.position.x, 3.67, 0.0000001);
    ASSERT_NEAR(waypoints[3].pose.position.y, -0.24, 0.0000001);

    ASSERT_NEAR(waypoints[4].pose.position.x, 1.07, 0.0000001);
    ASSERT_NEAR(waypoints[4].pose.position.y, -12.38, 0.0000001);
    ASSERT_NEAR(waypoints[5].pose.position.x, -5.32, 0.0000001);
    ASSERT_NEAR(waypoints[5].pose.position.y, -8.85, 0.0000001);
    ASSERT_NEAR(waypoints[6].pose.position.x, -0.56, 0.0000001);
    ASSERT_NEAR(waypoints[6].pose.position.y, 0.24, 0.0000001);
  }
}

TEST(bt_action, battery_checker_btn)
{
  auto node = rclcpp::Node::make_shared("battery_checker_btn_node");
  auto vel_pub = node->create_publisher<geometry_msgs::msg::Twist>("/output_vel", 100);

  BT::BehaviorTreeFactory factory;
  BT::SharedLibrary loader;

  factory.registerFromPlugin(loader.getOSName("br2_battery_checker_bt_node"));
  factory.registerFromPlugin(loader.getOSName("br2_patrol_bt_node"));

  std::string xml_bt =
    R"(
    <root main_tree_to_execute = "MainTree" >
      <BehaviorTree ID="MainTree">
          <ReactiveSequence>
              <BatteryChecker    name="battery_checker"/>
              <Patrol    name="patrol"/>
          </ReactiveSequence>
      </BehaviorTree>
    </root>)";

  auto blackboard = BT::Blackboard::create();
  blackboard->set("node", node);
  BT::Tree tree = factory.createTreeFromText(xml_bt, blackboard);

  rclcpp::Rate rate(10);
  geometry_msgs::msg::Twist vel;
  vel.linear.x = 0.8;

  bool finish = false;
  int counter = 0;
  while (!finish && rclcpp::ok()) {
    finish = tree.rootNode()->executeTick() == BT::NodeStatus::SUCCESS;

    vel_pub->publish(vel);

    rclcpp::spin_some(node);
    rate.sleep();
  }

  float battery_level;
  ASSERT_TRUE(blackboard->get("battery_level", battery_level));
  ASSERT_NEAR(battery_level, 94.6, 1.0);
}

TEST(bt_action, track_objects_btn_1)
{
  auto node = rclcpp::Node::make_shared("track_objects_btn_node");
  auto node_head_tracker = rclcpp_lifecycle::LifecycleNode::make_shared("head_tracker");

  bool finish = false;
  std::thread t([&]() {
      while (!finish) {rclcpp::spin_some(node_head_tracker->get_node_base_interface());}
    });

  BT::NodeConfiguration conf;
  conf.blackboard = BT::Blackboard::create();
  conf.blackboard->set("node", node);
  br2_bt_patrolling::BtLifecycleCtrlNode bt_node("TrackObjects", "head_tracker", conf);

  bt_node.change_state_client_ = bt_node.createServiceClient<lifecycle_msgs::srv::ChangeState>(
    "/head_tracker/change_state");
  ASSERT_TRUE(bt_node.change_state_client_->service_is_ready());

  bt_node.get_state_client_ = bt_node.createServiceClient<lifecycle_msgs::srv::GetState>(
    "/head_tracker/get_state");
  ASSERT_TRUE(bt_node.get_state_client_->service_is_ready());
  auto start = node->now();

  rclcpp::Rate rate(10);
  while (rclcpp::ok() && (node->now() - start) < 1s) {
    rclcpp::spin_some(node);
    rate.sleep();
  }

  ASSERT_EQ(bt_node.get_state(), lifecycle_msgs::msg::State::PRIMARY_STATE_UNCONFIGURED);
  bt_node.ctrl_node_state_ = lifecycle_msgs::msg::State::PRIMARY_STATE_UNCONFIGURED;
  ASSERT_FALSE(bt_node.set_state(lifecycle_msgs::msg::State::PRIMARY_STATE_ACTIVE));

  node_head_tracker->trigger_transition(lifecycle_msgs::msg::Transition::TRANSITION_CONFIGURE);

  start = node->now();
  while (rclcpp::ok() && (node->now() - start) < 1s) {
    rclcpp::spin_some(node);
    rate.sleep();
  }

  bt_node.ctrl_node_state_ = bt_node.get_state();

  ASSERT_TRUE(bt_node.set_state(lifecycle_msgs::msg::State::PRIMARY_STATE_ACTIVE));
  ASSERT_EQ(bt_node.get_state(), lifecycle_msgs::msg::State::PRIMARY_STATE_ACTIVE);

  start = node->now();
  while (rclcpp::ok() && (node->now() - start) < 1s) {
    rclcpp::spin_some(node);
    rate.sleep();
  }

  bt_node.ctrl_node_state_ = bt_node.get_state();

  ASSERT_TRUE(bt_node.set_state(lifecycle_msgs::msg::State::PRIMARY_STATE_INACTIVE));
  ASSERT_EQ(bt_node.get_state(), lifecycle_msgs::msg::State::PRIMARY_STATE_INACTIVE);

  finish = true;
  t.join();
}

TEST(bt_action, track_objects_btn_2)
{
  auto node = rclcpp::Node::make_shared("track_objects_btn_node");
  auto node_head_tracker = rclcpp_lifecycle::LifecycleNode::make_shared("head_tracker");

  bool finish = false;
  std::thread t([&]() {
      while (!finish) {rclcpp::spin_some(node_head_tracker->get_node_base_interface());}
    });

  BT::NodeConfiguration conf;
  conf.blackboard = BT::Blackboard::create();
  conf.blackboard->set("node", node);
  br2_bt_patrolling::BtLifecycleCtrlNode bt_node("TrackObjects", "head_tracker", conf);

  node_head_tracker->trigger_transition(lifecycle_msgs::msg::Transition::TRANSITION_CONFIGURE);

  rclcpp::Rate rate(10);
  auto start = node->now();
  while (rclcpp::ok() && (node->now() - start) < 1s) {
    rclcpp::spin_some(node);
    rate.sleep();
  }

  ASSERT_EQ(bt_node.tick(), BT::NodeStatus::RUNNING);

  ASSERT_TRUE(bt_node.change_state_client_->service_is_ready());
  ASSERT_TRUE(bt_node.get_state_client_->service_is_ready());

  ASSERT_EQ(bt_node.get_state(), lifecycle_msgs::msg::State::PRIMARY_STATE_ACTIVE);

  ASSERT_EQ(bt_node.tick(), BT::NodeStatus::RUNNING);

  bt_node.halt();

  start = node->now();
  while (rclcpp::ok() && (node->now() - start) < 1s) {
    rclcpp::spin_some(node);
    rate.sleep();
  }

  ASSERT_EQ(bt_node.get_state(), lifecycle_msgs::msg::State::PRIMARY_STATE_INACTIVE);

  finish = true;
  t.join();
}

TEST(bt_action, track_objects_btn_3)
{
  auto node = rclcpp::Node::make_shared("track_objects_btn_node");
  auto node_head_tracker = rclcpp_lifecycle::LifecycleNode::make_shared("head_tracker");

  node_head_tracker->trigger_transition(lifecycle_msgs::msg::Transition::TRANSITION_CONFIGURE);

  bool finish = false;
  std::thread t([&]() {
      while (!finish) {rclcpp::spin_some(node_head_tracker->get_node_base_interface());}
    });

  BT::BehaviorTreeFactory factory;
  BT::SharedLibrary loader;

  factory.registerFromPlugin(loader.getOSName("br2_track_objects_bt_node"));

  std::string xml_bt =
    R"(
    <root main_tree_to_execute = "MainTree" >
      <BehaviorTree ID="MainTree">
          <KeepRunningUntilFailure>
              <TrackObjects    name="track_objects"/>
          </KeepRunningUntilFailure>
      </BehaviorTree>
    </root>)";

  auto blackboard = BT::Blackboard::create();
  blackboard->set("node", node);
  auto start = node->now();
  rclcpp::Rate rate(10);

  {
    BT::Tree tree = factory.createTreeFromText(xml_bt, blackboard);

    ASSERT_EQ(
      node_head_tracker->get_current_state().id(),
      lifecycle_msgs::msg::State::PRIMARY_STATE_INACTIVE);

    while (rclcpp::ok() && (node->now() - start) < 1s) {
      tree.rootNode()->executeTick() == BT::NodeStatus::RUNNING;

      rclcpp::spin_some(node);
      rate.sleep();
    }
    ASSERT_EQ(
      node_head_tracker->get_current_state().id(),
      lifecycle_msgs::msg::State::PRIMARY_STATE_ACTIVE);
  }

  start = node->now();
  while (rclcpp::ok() && (node->now() - start) < 1s) {
    rclcpp::spin_some(node);
    rate.sleep();
  }

  ASSERT_EQ(
    node_head_tracker->get_current_state().id(),
    lifecycle_msgs::msg::State::PRIMARY_STATE_INACTIVE);

  finish = true;
  t.join();
}

TEST(bt_action, move_track_btn)
{
  auto node = rclcpp::Node::make_shared("move_btn_node");
  auto nav2_fake_node = std::make_shared<Nav2FakeServer>();
  auto node_head_tracker = rclcpp_lifecycle::LifecycleNode::make_shared("head_tracker");

  node_head_tracker->trigger_transition(lifecycle_msgs::msg::Transition::TRANSITION_CONFIGURE);

  nav2_fake_node->start_server();

  rclcpp::executors::SingleThreadedExecutor exe;
  exe.add_node(nav2_fake_node);
  exe.add_node(node_head_tracker->get_node_base_interface());
  bool finish = false;
  std::thread t([&]() {
      while (!finish) {exe.spin_some();}
    });

  BT::BehaviorTreeFactory factory;
  BT::SharedLibrary loader;

  factory.registerFromPlugin(loader.getOSName("br2_move_bt_node"));
  factory.registerFromPlugin(loader.getOSName("br2_track_objects_bt_node"));

  std::string xml_bt =
    R"(
    <root main_tree_to_execute = "MainTree" >
      <BehaviorTree ID="MainTree">
          <Parallel success_threshold="1" failure_threshold="1">
            <TrackObjects    name="track_objects"/>
            <Move    name="move" goal="{goal}"/>
          </Parallel>
      </BehaviorTree>
    </root>)";

  auto blackboard = BT::Blackboard::create();
  blackboard->set("node", node);

  geometry_msgs::msg::PoseStamped goal;
  blackboard->set("goal", goal);

  BT::Tree tree = factory.createTreeFromText(xml_bt, blackboard);

  ASSERT_EQ(
    node_head_tracker->get_current_state().id(),
    lifecycle_msgs::msg::State::PRIMARY_STATE_INACTIVE);

  rclcpp::Rate rate(10);
  auto start = node->now();
  auto finish_tree = false;
  while (rclcpp::ok() && (node->now() - start) < 1s) {
    finish_tree = tree.rootNode()->executeTick() == BT::NodeStatus::SUCCESS;

    rclcpp::spin_some(node);
    rate.sleep();
  }

  ASSERT_FALSE(finish_tree);
  ASSERT_EQ(
    node_head_tracker->get_current_state().id(),
    lifecycle_msgs::msg::State::PRIMARY_STATE_ACTIVE);

  while (rclcpp::ok() && !finish_tree) {
    finish_tree = tree.rootNode()->executeTick() == BT::NodeStatus::SUCCESS;

    rclcpp::spin_some(node);
    rate.sleep();
  }

  start = node->now();
  while (rclcpp::ok() && (node->now() - start) < 1s) {
    rclcpp::spin_some(node);
    rate.sleep();
  }

  ASSERT_EQ(
    node_head_tracker->get_current_state().id(),
    lifecycle_msgs::msg::State::PRIMARY_STATE_INACTIVE);

  finish = true;
  t.join();
}

int main(int argc, char ** argv)
{
  rclcpp::init(argc, argv);

  testing::InitGoogleTest(&argc, argv);
  return RUN_ALL_TESTS();
}
    \end{minted}
    \end{tcolorbox}
  \normalsize

 \footnotesize
\begin{tcolorbox}[sharp corners, colframe=gray!80, colback=LightGray, left=0pt, top=0pt, bottom=0pt, title=\texttt{br2\_bt\_patrolling/tests/CMakeLists.txt}]
  \begin{minted}[
    framesep=2mm,
    baselinestretch=0.8,
    bgcolor=LightGray,
    fontsize=\scriptsize
  ]{CMake}

ament_add_gtest(bt_action_test bt_action_test.cpp)
ament_target_dependencies(bt_action_test ${dependencies})
target_link_libraries(bt_action_test br2_track_objects_bt_node)
    \end{minted}
    \end{tcolorbox}
  \normalsize


